<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap集合简介</title>
    <url>/2024/07/10/HasnMap%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="1-HashMap集合简介"><a href="#1-HashMap集合简介" class="headerlink" title="1.HashMap集合简介"></a>1.HashMap集合简介</h2><p>HashMap基于哈希表的Map接口实现，是以key-Vaue存储形式存在，即主要用来存放键值对。HashMap的实<br>现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序<br>的。<br>    JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突（<strong>两个<br>对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同</strong>)而存在的(“拉链法”解决冲<br>突)JDK1.8以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为8）并<br>且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储</strong>。<br>    补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而<br>是选择进行数组扩容。<br>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑<br>树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所<br>述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考<br>treeifyBin方法。<br>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红<br>黑树时，效率也变的更高效。</p>
<p>小结：<br>特点：</p>
<ol>
<li>存取无序的</li>
<li>键和值位置都可以是null,但是键位置只能是一个null</li>
<li>键位置是唯一的，底层的数据结构控制键的</li>
<li>jdk1.8前数据结构是：链表+数组jdk1.8之后是：链表+数组+红黑树</li>
<li>阈值(边界值)&gt;8并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始搭建hexo</title>
    <url>/2024/07/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo/</url>
    <content><![CDATA[<ul>
<li>准备环境node.js</li>
<li>切换淘宝源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<ul>
<li>安装hexo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install  -g  hexo-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>验证hexo是否安装成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化hexo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##新建一个文件夹作为hexo的根目录</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<ul>
<li>hexo启动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<ul>
<li>博客编写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇博客文章&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成静态文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?vd_source=6a128c5132a08066dd8c2948fe5e50d4">参考链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>位运算符号</title>
    <url>/2024/07/10/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<img src="d9b621177848d14c0e4bf4f6db7bb8bd.png" alt="截图" style="zoom:50%;" />

<img src="39aa9a6b5c957be71fa161e839493de5.png" alt="截图" style="zoom:50%;" />

<img src="dfbee44eadb50646e843439d958480f5.png" alt="截图" style="zoom:50%;" />

<img src="779cf27779a825892b565d2730f413f2.png" alt="截图" style="zoom:50%;" />

<img src="73abc9c132b7763948dc1e38eecda717.png" alt="截图" style="zoom:50%;" />

<img src="c974b5ed76058f31c7fa0d7ae8a91878.png" alt="截图" style="zoom:50%;" />

<img src="b3853f5b461d17a7fb98e770a5b444a4.png" alt="截图" style="zoom:50%;" />

<img src="c8cd61a86fb17685bb404424480e7986.png" alt="截图" style="zoom:50%;" />

<img src="8d85ae1fac0bf36ee24aada00b326d17.png" alt="截图" style="zoom:50%;" />]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap集合扩容方法resize的源码解析</title>
    <url>/2024/07/10/HashMap%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95resize%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 扩容方法</span><br><span class="line"> * 1. 计算新的容量和新的阈值</span><br><span class="line"> * 2. 创建新的数组</span><br><span class="line"> * 3. 将旧数组的元素迁移到新的数组中</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    // 如果旧数组不为空</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果旧数组的容量 &gt;= MAXIMUM_CAPACITY，则将阈值设置为Integer.MAX_VALUE，并返回旧数组</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果旧数组的容量 &gt;= DEFAULT_INITIAL_CAPACITY，则将新数组的容量设置为旧数组的容量*2，并将阈值设置为旧阈值*2</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果旧阈值大于0，则将新数组的容量设置为旧阈值，并将阈值设置为旧阈值</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 否则，将新数组的容量设置为DEFAULT_INITIAL_CAPACITY，并将阈值设置为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果新阈值为0，则将新阈值设置为新数组的容量 * 负载因子，大于等于MAXIMUM_CAPACITY时，设置为Integer.MAX_VALUE</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    // 如果旧数组不为空</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 遍历旧数组中的每个元素</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            // 如果当前元素不为空</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 如果当前元素的下一个元素为空</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 如果当前元素是一个树节点</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                // 否则，保持元素顺序</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
