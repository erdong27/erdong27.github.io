{"meta":{"title":"erdong的博客","subtitle":"毕竟几人真得鹿,不知终日梦为鱼","description":"JAVA后端开发攻城狮。","author":"erdong","url":"https://erdong27.github.io","root":"/"},"pages":[{"title":"link","date":"2024-07-10T02:51:30.000Z","updated":"2024-07-10T02:51:53.992Z","comments":true,"path":"link/index.html","permalink":"https://erdong27.github.io/link/index.html","excerpt":"","text":""},{"title":"留下你的想法","date":"2024-07-10T02:02:18.000Z","updated":"2024-07-10T02:39:51.004Z","comments":true,"path":"messageboard/index.html","permalink":"https://erdong27.github.io/messageboard/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-07-10T02:01:37.000Z","updated":"2024-07-10T05:51:30.066Z","comments":false,"path":"categories/index.html","permalink":"https://erdong27.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-07-10T01:59:50.000Z","updated":"2024-07-10T05:51:15.322Z","comments":false,"path":"tags/index.html","permalink":"https://erdong27.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"位运算符号","slug":"位运算符号","date":"2024-07-10T05:41:38.000Z","updated":"2024-07-10T05:49:50.308Z","comments":true,"path":"2024/07/10/位运算符号/","permalink":"https://erdong27.github.io/2024/07/10/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"","categories":[{"name":"位运算","slug":"位运算","permalink":"https://erdong27.github.io/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://erdong27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"从0开始搭建hexo","slug":"从0开始搭建hexo","date":"2024-07-10T01:14:28.629Z","updated":"2024-07-10T01:14:28.630Z","comments":true,"path":"2024/07/10/从0开始搭建hexo/","permalink":"https://erdong27.github.io/2024/07/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo/","excerpt":"","text":"准备环境node.js 切换淘宝源 1npm install -g cnpm --registry=https://registry.npmmirror.com 安装hexo 1cnpm install -g hexo-cli 验证hexo是否安装成功 1hexo -v 初始化hexo 12##新建一个文件夹作为hexo的根目录hexo init hexo启动 1hexo s 博客编写 1hexo n &quot;我的第一篇博客文章&quot; 生成静态文件 1hexo g 参考链接","categories":[],"tags":[]},{"title":"HashMap集合扩容方法resize的源码解析","slug":"HashMap集合扩容方法resize的源码分析","date":"2024-07-09T16:57:12.608Z","updated":"2024-07-09T17:54:26.148Z","comments":true,"path":"2024/07/10/HashMap集合扩容方法resize的源码分析/","permalink":"https://erdong27.github.io/2024/07/10/HashMap%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95resize%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 扩容方法 * 1. 计算新的容量和新的阈值 * 2. 创建新的数组 * 3. 将旧数组的元素迁移到新的数组中 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果旧数组不为空 if (oldCap &gt; 0) &#123; // 如果旧数组的容量 &gt;= MAXIMUM_CAPACITY，则将阈值设置为Integer.MAX_VALUE，并返回旧数组 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 如果旧数组的容量 &gt;= DEFAULT_INITIAL_CAPACITY，则将新数组的容量设置为旧数组的容量*2，并将阈值设置为旧阈值*2 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 如果旧阈值大于0，则将新数组的容量设置为旧阈值，并将阈值设置为旧阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 否则，将新数组的容量设置为DEFAULT_INITIAL_CAPACITY，并将阈值设置为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新阈值为0，则将新阈值设置为新数组的容量 * 负载因子，大于等于MAXIMUM_CAPACITY时，设置为Integer.MAX_VALUE if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果旧数组不为空 if (oldTab != null) &#123; // 遍历旧数组中的每个元素 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果当前元素不为空 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果当前元素的下一个元素为空 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果当前元素是一个树节点 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 否则，保持元素顺序 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","categories":[],"tags":[]},{"title":"HashMap集合简介","slug":"HasnMap集合简介","date":"2024-07-09T16:53:36.580Z","updated":"2024-07-09T17:53:48.004Z","comments":true,"path":"2024/07/10/HasnMap集合简介/","permalink":"https://erdong27.github.io/2024/07/10/HasnMap%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1.HashMap集合简介HashMap基于哈希表的Map接口实现，是以key-Vaue存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突（两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的(“拉链法”解决冲突)JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。 补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考treeifyBin方法。当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 小结：特点： 存取无序的 键和值位置都可以是null,但是键位置只能是一个null 键位置是唯一的，底层的数据结构控制键的 jdk1.8前数据结构是：链表+数组jdk1.8之后是：链表+数组+红黑树 阈值(边界值)&gt;8并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。","categories":[],"tags":[]}],"categories":[{"name":"位运算","slug":"位运算","permalink":"https://erdong27.github.io/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://erdong27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}