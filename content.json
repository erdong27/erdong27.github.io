{"meta":{"title":"erdong","subtitle":"一万年太久,只争朝夕。","description":"JAVA后端开发攻城狮。","author":"erdong","url":"https://erdong27.github.io","root":"/"},"pages":[{"title":"归档","date":"2024-07-10T07:00:38.000Z","updated":"2024-07-10T07:02:13.278Z","comments":false,"path":"archives/index.html","permalink":"https://erdong27.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-10T08:13:36.614Z","updated":"2024-07-10T08:13:16.462Z","comments":true,"path":"css/checkbox.css","permalink":"https://erdong27.github.io/css/checkbox.css","excerpt":"","text":"input[type=\"checkbox\"] { display: none !important; } input[type=\"checkbox\"] + label::before { content: '\\a0'; display: inline-block; margin-right: 0.2em; border: 1px solid; border-radius: 0.2em; width: 0.8em; height: 0.8em; vertical-align: 0.1em; text-indent: 0.1em; line-height: 0.7; cursor: not-allowed; } input[type=\"checkbox\"]:checked + label::before { content: '\\2714'; } 作者: 默烦 链接: https://mofan212.github.io/posts/Something-About-Blog/ 来源: Mofan 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"关于","date":"2024-07-10T07:17:45.000Z","updated":"2024-07-10T07:30:23.981Z","comments":false,"path":"about/index.html","permalink":"https://erdong27.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-10T08:14:49.003Z","updated":"2024-07-10T08:14:49.003Z","comments":true,"path":"js/checkbox.js","permalink":"https://erdong27.github.io/js/checkbox.js","excerpt":"","text":"/*设置 checkbox 为只读*/ window.onload = function(){ var inputs = document.getElementsByTagName(\"input\"); for(var i = 0;i < inputs.length; i++){ if(inputs[i].type == \"checkbox\"){ inputs[i].onclick = function() { this.checked = !this.checked; } } } }"},{"title":"友链","date":"2024-07-10T02:51:30.000Z","updated":"2024-07-10T07:16:26.471Z","comments":false,"path":"link/index.html","permalink":"https://erdong27.github.io/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-07-10T02:01:37.000Z","updated":"2024-07-10T05:51:30.066Z","comments":false,"path":"categories/index.html","permalink":"https://erdong27.github.io/categories/index.html","excerpt":"","text":""},{"title":"留下你的想法","date":"2024-07-10T02:02:18.000Z","updated":"2024-07-10T07:25:27.063Z","comments":true,"path":"messageboard/index.html","permalink":"https://erdong27.github.io/messageboard/index.html","excerpt":"","text":"留言须知 严禁发表违反中华人民共和国相关法律的言论，包括但不限于反动、分裂、色情、诈骗等"},{"title":"标签","date":"2024-07-10T01:59:50.000Z","updated":"2024-07-10T05:51:15.322Z","comments":false,"path":"tags/index.html","permalink":"https://erdong27.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Lambda表达式函数式编程","slug":"Lambda表达式函数式编程","date":"2024-07-25T15:05:00.000Z","updated":"2024-07-27T01:02:25.952Z","comments":true,"path":"2024/07/25/Lambda表达式函数式编程/","permalink":"https://erdong27.github.io/2024/07/25/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"合格函数 输入的参数相同，不管执行多少次，输出的结果也相同 使用了外界的数据，这个外界的数据要保持不变 方法与函数并无本质不同 1234567891011121314151617181920212223242526272829303132333435public class People implements Serializable&#123; private static final long serialVersionUID = 4874959641335020208L; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName(People this) &#123;//getName()会在编译的时候变成getName(People this) return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public static void main(String[] args) &#123; People people=new People(&quot;张三&quot;,18); System.out.println(people.getName());//getName(People this) &#125;&#125; 有形函数 12345678910111213141516public interface Operation &#123; int calculate(int a,int b); class MyOperation &#123; //普通函数 static public int add(int a,int b) &#123; return a+b; &#125; &#125; //函数化为对象 Operation add = (a,b) -&gt; a+b; public static void main(String[] args) &#123; System.out.println(MyOperation.add(1,2)); System.out.println(add.calculate(1,2)); &#125;&#125; 前者是纯粹的一条两数加法规则，它的位置是固定的，要使用它，需要过MyOperation.add找它，然后执行 而后者（add对象）就像长了腿，它的位置是可以变化的，想去哪里就去哪里，哪里要用到这条加法规则，把它传递过去 接口的目的是为了将来用它来执行函数对象，此接口中只能有一个方法定义 函数对象行为参数化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.github.ed.domain;import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class People implements Serializable&#123; private static final long serialVersionUID = 4874959641335020208L; private String name; private int age; private String sex; public People(String name, int age, String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; static List&lt;People&gt; filter(List&lt;People&gt; list, Lambda lambda)&#123; List&lt;People&gt; result=new ArrayList&lt;&gt;(); for (People people : list) &#123; if(lambda.test(people))&#123; result.add(people); &#125; &#125; return result; &#125; interface Lambda&#123; boolean test(People people); &#125; //判断条件传入其中 不用修改 public static void main(String[] args) &#123; List&lt;People&gt; list=new ArrayList&lt;&gt;(); list.add(new People(&quot;张三&quot;,17,&quot;男&quot;)); list.add(new People(&quot;李四&quot;,16,&quot;女&quot;)); list.add(new People(&quot;王五&quot;,20,&quot;女&quot;)); list.add(new People(&quot;赵六&quot;,30,&quot;男&quot;)); System.out.println(filter(list, people -&gt; people.getAge() &lt; 18)); System.out.println(filter(list, people -&gt; people.getSex().equals(&quot;男&quot;))); &#125;&#125; 延迟执行123456789101112131415161718192021222324252627282930313233public class LazyFunction &#123; private final Supplier&lt;String&gt; lazyValue; private boolean flag; public LazyFunction(boolean flag,Supplier&lt;String&gt; lazyValue) &#123; this.lazyValue = lazyValue; this.flag=flag; &#125; public String getValue() &#123; if(flag)&#123; return lazyValue.get(); &#125; return null; &#125;&#125; @Test public void testGetValue_ShouldExecuteLazyFunction() &#123; // 模拟一个延迟执行的 Supplier Supplier&lt;String&gt; lazyValue = () -&gt; &#123; // 假设这个计算是昂贵的或需要延迟执行 return &quot;Expensive computation result&quot;; &#125;; // 创建 LazyFunction 实例 LazyFunction lazyFunction = new LazyFunction(true,lazyValue); // 调用 getValue 并验证结果 String result = lazyFunction.getValue(); assertEquals(&quot;Expensive computation result&quot;, result); &#125; 函数对象表现形式 Lambda表达式（功能更全面） 12345678910(int a ,int b)-&gt;a+b;//明确指出参数类型(int a ,int b)-&gt;&#123;int c=a+b;return c;&#125;//代码多于一行，不能省略&#123;&#125;以及最后一行的returnLambdal lambda=(a,b)-&gt;a+ b;interface Lambda1 &#123; int op(int a, int b);&#125;//可以根据上下文推测出参数类型时，可以省略参数类型a-&gt;a只有一个参数时，可以省略（） 方法引用（写法更简洁） 1234567Math:max (int a,int b)-&gt; Math.max(a,b);Student::getName (Student student)-&gt;student.getName();System.out::println (Object obj)-&gt;System.out::println(obj);Student::new ()-&gt;new Student(); 函数对象类型 如何归类？ 根据参数个数类型相同，返回值类型相同 进行分类 函数式接口：仅包含一个抽象方法，用@FunctionalInterface注解来检查 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; // Type1 obj1= a-&gt;(a&amp;1)== 0; // Type1 obj2= a-&gt; BigInteger.valueOf(a).isProbablePrime( 100); // Type2 obj3= (int a,int b,int c)-&gt;a+ b + c; // Type3 obj4= (int a,int b)-&gt;a- b; // Type3 obj5= (int a,int b)-&gt; a * b; // Type4&lt;Student&gt; obj6= ()-&gt;new Student(); // Type5&lt;Student,String&gt; obj7= stu-&gt;stu.getName(); // Type5&lt;Student,Integer&gt; obj8= stu-&gt;stu.getScore(); // Type6&lt;Student,Integer&gt; obj9= (Student stu,Integer i)-&gt;stu.setScore(i); //jdk已经定义了一些Function IntPredicate obj1= a-&gt;(a&amp;1)== 0; IntPredicate obj2= a-&gt; BigInteger.valueOf(a).isProbablePrime( 100); Type2 obj3= (int a,int b,int c)-&gt;a+ b + c; IntBinaryOperator obj4= (int a, int b)-&gt;a- b; IntBinaryOperator obj5= (int a,int b)-&gt; a * b; Supplier&lt;Student&gt; obj6= ()-&gt;new Student(); Function&lt;Student,String&gt; obj7= stu-&gt;stu.getName(); Function&lt;Student,Integer&gt; obj8= stu-&gt;stu.getScore(); BiConsumer&lt;Student,Integer&gt; obj9= (Student stu,Integer i)-&gt;stu.setScore(i);&#125;interface Type1&#123; boolean op(int a);&#125;interface Type2&#123; int op(int a,int b,int c);&#125;interface Type3&#123; int op(int a,int b);&#125;interface Type4&lt;T&gt;&#123; T op();&#125;interface Type5&lt;T,R&gt;&#123; R op(T t);&#125;interface Type6&lt;T,P&gt;&#123; void op(T t,P p);&#125; 常见的函数接口 1234567891011121314151617181920211.Runnable()-void2.Callable()-&gt;T3.Comparator(T,T)-&gt;int//Consumer：消费者 没有返回值的4.Consumer,BiConsumer,IntConsumer,LongConsumer,DoubleConsumer(T)-&gt;void,Bi是两参，Int指参数是int//有参数 并且有返回值的5.Function,BiFunction,Int Long Double ..(T)-&gt;R,Bi是两参，Int指参数是int//Predicate:条件判断 返回的是boolean6.Predicate,BiPredicate,Int Long Double ..(T)-&gt;boolean,Bi是两参，Int指参数是int//没有参数 只有返回结果7.Supplier,Int Long Double ..()-&gt;T,Int指返回值是int//参数类型 跟返回的参数一致8.Unaryoperator,Binaryoperator,Int Long Double ..(T)-&gt;T,Unary一参，Binary两参，Int指参数是int 方法引用 方法引用：将现有方法的调用华为函数对象 123456//静态方法(String s)-&gt;Integer.parseInt(s) Integer::parseInt//非静态方法(stu)-&gt;stu.getName() Student:getName//构造方法()-new Student() Student::new 类名::静态方法 类名::非静态方法 对象::非静态方法 类名::new this::非静态方法 super::非静态方法 都是在类内部使用的 特例：对于无需返回值的所数接口，例如Consumer和 Runnable它们可以配会有返回值的雨数对象使用 123456789101112131415public static void main(String[] args) &#123; Consumer&lt;Object&gt; x=People::print1; Function&lt;Object,Integer&gt; y=People::print2; //不会报错 Consumer不关心返回值 Consumer&lt;Object&gt; z=People::print2;&#125;static void print1(Object obj)&#123; System.out.println(obj);&#125;static int print2(Object obj)&#123; System.out.println(obj); return 1;&#125; 闭包(Closure)与柯里化(Currying)什么是闭包？ 函数与对象和它外界变量绑定在一起 闭包的限制闭包变量必须是final或effective final 闭包的作用给函数执行提供数据的手段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.io.Serializable;public class People implements Serializable&#123;private static final long serialVersionUID = 4874959641335020208L;private String name;private int age;private String sex;public People(String name, int age, String sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;public String getName() &#123; return this.name;&#125;public void setName(String name) &#123; this.name = name;&#125;public int getAge() &#123; return age;&#125;public void setAge(int age) &#123; this.age = age;&#125;public String getSex() &#123; return sex;&#125;public void setSex(String sex) &#123; this.sex = sex;&#125;@Overridepublic String toString() &#123; return &quot;People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;;&#125; @FunctionalInterface interface Lambda&#123; int op(int y); &#125; static void highorder(Lambda lambda) &#123; System.out.println(lambda.op(1)); &#125; public static void main(String[]args)&#123; /** * 函数对象（int y）-&gt;x+y 与 外部变量x形成了闭包 * 外部变量必须是final * 或 effective final：虽然没有被final修饰 但是这个值没有被修改 */ int x=10; highorder((int y)-&gt;x +y); /** * 对于对象 只对对象本身进行了限制 对象内部的属性并没有被限制修改 */ People people=new People(&quot;张三&quot;,18,&quot;男&quot;); Lambda lambda = y-&gt; people.getAge() + y; highorder(lambda); people.age=40; highorder(lambda); &#125;&#125; 什么是柯里化让接收多个参数的函数转换成一系列接收一个参数的函数 如何实现柯里化结合闭包实现 柯里化的作用让函数分步执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445@FunctionalInterface interface F1&#123; F2 op(List&lt;Integer&gt; list); &#125; @FunctionalInterface interface F2&#123; F3 op(List&lt;Integer&gt; list); &#125; @FunctionalInterface interface F3&#123; List&lt;Integer&gt; op(List&lt;Integer&gt; list); &#125; static F2 step1()&#123; F1 f1= a-&gt;b-&gt;c-&gt;&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.addAll(a); list.addAll(b); list.addAll(c); return list; &#125;; return f1.op(Arrays.asList(1,2,3)); &#125; static F3 step2(F2 f2)&#123; return f2.op(Arrays.asList(4, 5, 6)); &#125; static List&lt;Integer&gt; step3(F3 f3)&#123; return f3.op(Arrays.asList(7, 8, 9)); &#125; /* 目标：把三份数据合在一起，逻辑既定，们数据不能一次得到 a-&gt;函数对象 b-&gt;函数对象 c-&gt;完成合升 */ public static void main(String[]args)&#123; System.out.println(step3(step2(step1()))); &#125; 高阶函数 所谓高阶，就是指它是其它函数对象的使用者 作用： 将通用、复杂的逻辑隐含在高阶函数内 将易变、未定的逻辑放在外部的函数对象中 应用：内循环12345678910111213public static void main(String[]args)&#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7); //需求：逆序遍历集合，只想负责元素处理，不改变集合 hiOrder(list, System.out::println);&#125;static &lt;T&gt; void hiOrder(List&lt;T&gt; list, Consumer&lt;T&gt; consumer)&#123; ListIterator&lt;T&gt; iterator = list.listIterator(list.size()); while (iterator.hasPrevious())&#123; T value = iterator.previous(); consumer.accept(value); &#125;&#125; 应用：二叉树循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import lombok.Getter;import java.util.function.Consumer;public class TreeNode &#123; @Getter int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; public TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125; @Override public String toString() &#123; return String.format(&quot;%d&quot;,val); &#125; public static void recursiveTraversal(TreeNode root, Type type, Consumer&lt;TreeNode&gt; consumer) &#123; if (root == null) return; //前序处理值 if (type == Type.PRE) &#123; consumer.accept(root); &#125; recursiveTraversal(root.left, type, consumer); //中序处理值 if (type == Type.IN) &#123; consumer.accept(root); &#125; recursiveTraversal(root.right, type, consumer); //后序处理值 if (type == Type.POST) &#123; consumer.accept(root); &#125; &#125; enum Type&#123; PRE, IN, POST &#125; public static void main(String[] args) &#123; TreeNode root = new TreeNode( 1, new TreeNode(2, new TreeNode(4, null, null), null), new TreeNode(3, new TreeNode(5, null, null), null) ); recursiveTraversal(root, Type.PRE, System.out::print); System.out.println(); recursiveTraversal(root, Type.IN, System.out::print); System.out.println(); recursiveTraversal(root, Type.POST, System.out::print); System.out.println(); &#125;&#125; 自定义简单流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.StringJoiner;import java.util.concurrent.atomic.AtomicInteger;import java.util.function.BiConsumer;import java.util.function.BinaryOperator;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import java.util.function.Supplier;public class SimpleStream&lt;T&gt; &#123; private final Collection&lt;T&gt; collection; private SimpleStream(Collection&lt;T&gt; collection)&#123; this.collection=collection; &#125; public static &lt;T&gt; SimpleStream&lt;T&gt; of(Collection&lt;T&gt; collection) &#123; return new SimpleStream&lt;&gt;(collection); &#125; public &lt;R&gt; SimpleStream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)&#123; List&lt;R&gt; list=new ArrayList&lt;&gt;(); for (T t : collection) &#123; R apply = mapper.apply(t); list.add(apply); &#125; return new SimpleStream&lt;&gt;(list); &#125; public SimpleStream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)&#123; List&lt;T&gt; list=new ArrayList&lt;&gt;(); for (T t : collection) &#123; if(predicate.test(t))&#123; list.add(t); &#125; &#125; return new SimpleStream&lt;&gt;(list); &#125; /** * 化简 * @param o 代表p的初始值 */ public T reduce(T o,BinaryOperator&lt;T&gt; operator)&#123; T p=o;//上次合并的结果 for (T t : collection) &#123;//t是本次遍历的值 p=operator.apply(t,p); &#125; return p; &#125; /** * 收集 * @param supplier 用来创建容器 * @param consumer 用来向容器中添加元素 * @param &lt;C&gt; 代表容器类型 */ public &lt;C&gt; C collect(Supplier&lt;C&gt; supplier,BiConsumer&lt;C,T&gt; consumer)&#123; C c = supplier.get();//创建容器 for (T t : collection) &#123; consumer.accept(c,t);//向容器中添加元素 &#125; return c; &#125; void forEach(Consumer&lt;? super T&gt; action)&#123; for (T t : collection) &#123; action.accept(t); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3,4,5,1, 2, 3,4,5); SimpleStream.of(list).filter(i -&gt; (i&amp;1)==1).map(i -&gt; i * i).forEach(System.out::println); System.out.println(SimpleStream.of(list).reduce(Integer.MAX_VALUE, Integer::min)); System.out.println(SimpleStream.of(list).reduce(Integer.MIN_VALUE, Integer::max)); System.out.println(SimpleStream.of(list).reduce(0, Integer::sum)); HashSet&lt;Object&gt; collect1 = SimpleStream.of(list).collect(HashSet::new, HashSet::add); System.out.println(collect1); StringBuffer collect2 = SimpleStream.of(list).collect(StringBuffer::new, StringBuffer::append); System.out.println(collect2); StringJoiner collect3 = SimpleStream.of(list).collect(() -&gt; new StringJoiner(&quot;-&quot;), (sj, j) -&gt; sj.add(String.valueOf(j))); System.out.println(collect3); HashMap&lt;Integer, Integer&gt; collect4 = SimpleStream.of(list).collect(HashMap::new, (map, t) -&gt; &#123; if (!map.containsKey(t)) &#123; map.put(t, 1); &#125; else &#123; Integer o = map.get(t); map.put(t, o + 1); &#125; &#125;); System.out.println(collect4); HashMap&lt;Integer, Integer&gt; collect5 = SimpleStream.of(list).collect(HashMap::new, (map, t) -&gt; &#123; if (!map.containsKey(t)) &#123; map.put(t, 1); &#125; else &#123; Integer o = map.get(t); map.put(t, o + 1); &#125; &#125;); System.out.println(collect5); /* 如果key在map中不存在，将key连同新生成的value值存入map,并返回value 如果key在map中存在，会返回此key上次的value值 */ HashMap&lt;Integer, AtomicInteger&gt; collect6 = SimpleStream.of(list).collect(HashMap::new, (map, t) -&gt; map.computeIfAbsent(t, k-&gt;new AtomicInteger()).getAndIncrement()); System.out.println(collect6); &#125;&#125; Stream API过滤-filter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import lombok.AllArgsConstructor;import lombok.Data;import java.util.stream.Stream;@AllArgsConstructor@Datapublic class Fruit &#123; private String cname; private String name; private String category; private String color; public static void main(String[] args) &#123; Stream.of(new Fruit( &quot;草莓&quot;, &quot;Strawberry&quot;, &quot;浆果&quot;, &quot;红色&quot;), new Fruit( &quot;桑甚&quot;, &quot;MuLberry&quot;, &quot;浆果&quot;, &quot;紫色&quot;), new Fruit( &quot;杨梅&quot;, &quot;Waxberry&quot;, &quot;浆果&quot;, &quot;红色&quot;), new Fruit( &quot;核桃&quot;, &quot;Walnut&quot;, &quot;坚果&quot;, &quot;棕色&quot;), new Fruit( &quot;花生&quot;, &quot;Peanut&quot;, &quot;坚果&quot;, &quot;棕色&quot;), new Fruit( &quot;蓝莓&quot;, &quot;BLueberry&quot;, &quot;浆果&quot;, &quot;蓝色&quot;)).filter(f-&gt;f.getCategory().equals(&quot;浆果&quot;)).filter(f-&gt;f.getColor().equals(&quot;蓝色&quot;)).forEach(System.out::println); &#125;&#125; 映射-map123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import lombok.AllArgsConstructor;import lombok.Data;import java.util.stream.Stream;@AllArgsConstructor@Datapublic class Fruit &#123; private String cname; private String name; private String category; private String color; public static void main(String[] args) &#123; Stream.of(new Fruit( &quot;草莓&quot;, &quot;Strawberry&quot;, &quot;浆果&quot;, &quot;红色&quot;), new Fruit( &quot;桑甚&quot;, &quot;MuLberry&quot;, &quot;浆果&quot;, &quot;紫色&quot;), new Fruit( &quot;杨梅&quot;, &quot;Waxberry&quot;, &quot;浆果&quot;, &quot;红色&quot;), new Fruit( &quot;核桃&quot;, &quot;Walnut&quot;, &quot;坚果&quot;, &quot;棕色&quot;), new Fruit( &quot;花生&quot;, &quot;Peanut&quot;, &quot;坚果&quot;, &quot;棕色&quot;), new Fruit( &quot;蓝莓&quot;, &quot;BLueberry&quot;, &quot;浆果&quot;, &quot;蓝色&quot;)).map(f-&gt;f.getCname()+&quot;酱&quot;).forEach(System.out::println); &#125;&#125; 扁平化(降维)-flatMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import lombok.AllArgsConstructor;import lombok.Data;import java.util.Arrays;import java.util.List;import java.util.stream.Stream;@AllArgsConstructor@Datapublic class Fruit &#123; private String cname; private String name; private String category; private String color; public static void main(String[] args) &#123; List&lt;Fruit&gt; fruitList1 = Arrays.asList(new Fruit( &quot;草莓&quot;, &quot;Strawberry&quot;, &quot;浆果&quot;, &quot;红色&quot;), new Fruit( &quot;桑甚&quot;, &quot;MuLberry&quot;, &quot;浆果&quot;, &quot;紫色&quot;), new Fruit( &quot;杨梅&quot;, &quot;Waxberry&quot;, &quot;浆果&quot;, &quot;红色&quot;), new Fruit( &quot;核桃&quot;, &quot;Walnut&quot;, &quot;坚果&quot;, &quot;棕色&quot;)); List&lt;Fruit&gt; fruitList2 = Arrays.asList(new Fruit( &quot;花生&quot;, &quot;Peanut&quot;, &quot;坚果&quot;, &quot;棕色&quot;), new Fruit( &quot;蓝莓&quot;, &quot;BLueberry&quot;, &quot;浆果&quot;, &quot;蓝色&quot;)); Stream.of(fruitList1, fruitList2).flatMap((fruits)-&gt;fruits.stream()).forEach(System.out::println); Integer[][]array2D =&#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;, &#125;; Arrays.stream(array2D).flatMap(a-&gt;Arrays.stream(a)).forEach(System.out::println); &#125;&#125; 构建流 三种构建方式： 从集合构建 集合.stream() 从数组构建 Arrays.stream(数据) 从对象构建 Stream.of(对象 …) 1234567891011121314151617181920public static void main(String[] args) &#123; //1.从集合创建 Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); set.add(1); set.add(2); set.add(3); set.stream().forEach(System.out::println); Map&lt;String ,Integer&gt; map=new HashMap&lt;&gt;(); map.put(&quot;a&quot;,1); map.put(&quot;b&quot;,2); map.put(&quot;c&quot;,3); map.entrySet().stream().forEach(System.out::println); //2.从数组构建 int [] array =new int[]&#123;1,2,3&#125;; Arrays.stream(array).forEach(System.out::println); //3.从对象构建 Stream.of(1,2,3,4,5).forEach(System.out::println); &#125; 流的合并与截取 合并 Stream.concat(流1,流2); 截取流的一部分 根据位置 流.skip(?).limit(?) 根据条件 流.takeWhile(条件) 流.dropWhile(条件) 12345678910111213141516171819202122232425public static void main(String[] args) &#123; //1.合并流 Stream&lt;Integer&gt; s1 = Stream.of(1, 2, 3); Stream&lt;Integer&gt; s2 = Stream.of(4, 5, 6); Stream&lt;Integer&gt; s3 = Stream.concat(s1, s2); s3.forEach(System.out::print); System.out.println(); /* 2.截取 skip(long n) 跳过n个元素 保留剩下的 limit(long n) 保留n个数据 剩下的不要 */ //保留4,5 Stream&lt;Integer&gt; s4 = Stream.of(1, 2, 3,4,5,6); s4.skip(3).limit(2).forEach(System.out::print); System.out.println(); /* 3.截取- 根据条件确定截取的位置 takeWhile(Predicate p) 条件成立保留 一旦条件不成立 剩下的不要 dropWhile(Predicate p) 条件成立舍弃 一旦条件不成立 剩下的保留 注意：takeWhile和dropWhile是短路操作 */&#125; 生成流 不用现有数据生成Stream对象 简单生成 IntStream.rang(...) 依赖上一个值 IntStream.iterate(...) 不依赖上一个值IntStream.generate(...) 1234567891011121314151617public static void main(String[] args) &#123; //1.IntStream.rang(...) IntStream.range(1,10).forEach(System.out::print); System.out.println(&quot;===============&gt;&quot;); IntStream.rangeClosed(1,10).forEach(System.out::print); System.out.println(&quot;===============&gt;&quot;); //2.依赖上一个值 IntStream.iterate() // 生成奇数列 可以根据上一个元素来生成当前元素 IntStream.iterate(1,x-&gt;x+2).limit(5).forEach(System.out::println); System.out.println(&quot;===============&gt;&quot;); // IntStream.iterate(1,x-&gt;x&lt;=9,x-&gt;x+2).limit(10).forEach(System.out::print); //3.不依赖上一个值`IntStream.generate(...) IntStream.generate(()-&gt; ThreadLocalRandom.current().nextInt(100)).limit(5).forEach(System.out::println); System.out.println(&quot;===============&gt;&quot;); ThreadLocalRandom.current().ints(5).forEach(System.out::println);&#125; 查找与判断 查找 filter(Predicate p )findAny() filter(Predicate p )findFirst() 判断 anyMatch(Predicate p) allMatch(Predicate p) noneMatch(Predicate p) 12345678910111213141516171819202122public static void main(String[] args) &#123; //1.findFirst 找到第一个元素 IntStream stream1 =IntStream.of(1,2,3,4,5,6,7); System.out.println(stream1.filter(x -&gt; (x &amp; 1) == 0).findFirst()); IntStream stream2 =IntStream.of(1,3,5,7); System.out.println(stream2.filter(x -&gt; (x &amp; 1) == 0).findFirst().orElse(-1)); IntStream stream3 =IntStream.of(1,2,3,4,5,6,7); stream3.filter(x -&gt; (x &amp; 1) == 0).findFirst().ifPresent(System.out::println); //2.findAny 找到任意一个元素 IntStream stream4 =IntStream.of(1,2,3,4,5,6,7); stream4.filter(x -&gt; (x &amp; 1) == 0).findAny().ifPresent(System.out::println); //3.anymatch 有一个元素满足 返回true IntStream stream5 =IntStream.of(1,2,3,4,5); System.out.println(stream5.anyMatch(x -&gt; (x &amp; 1) == 0)); //4.allMatch 所有元素都要满足 返回true IntStream stream6 =IntStream.of(2,4,6,8); System.out.println(stream6.allMatch(x -&gt; (x &amp; 1) == 0)); //5. noneMatch 所有元素都不满足 返回true IntStream stream7 =IntStream.of(1,3,5,7); System.out.println(stream7.noneMatch(x -&gt; (x &amp; 1) == 0));&#125; 去重与排序 去重 流.distinct() 排序 sorted(...) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public static void main(String[] args) &#123; //1.去重 IntStream stream1 = IntStream.of(1, 2, 3, 1, 2, 3, 3, 4, 5); stream1.distinct().forEach(System.out::println); Stream&lt;Hero&gt; stream2 = Stream.of( new Hero(&quot;令孤冲&quot;, 90), new Hero(&quot;风清扬&quot;, 98), new Hero(&quot;独孤求败&quot;, 100), new Hero(&quot;方证&quot;, 92), new Hero(&quot;东方不败&quot;, 98), new Hero(&quot;冲虚&quot;, 90), new Hero(&quot;向问天&quot;, 88), new Hero(&quot;任我行&quot; , 92), new Hero( &quot;不戒&quot;, 88) ); stream2// .sorted((a,b)-&gt;a.strength&gt;b.strength?1:a.strength==b.strength?0:-1)// .sorted((a,b)-&gt; Integer.compare(a.strength, b.strength))// .sorted(Comparator.comparingInt(h-&gt;h.strength))// .sorted(Comparator.comparingInt(Hero::getStrength))// .sorted(Comparator.comparingInt(Hero::getStrength).reversed()) .sorted(Comparator.comparingInt(Hero::getStrength).reversed().thenComparingInt(h-&gt;h.getName().length()))//按武力值降序 武力值相等 按名字长度升序 .forEach(System.out::println); &#125; static class Hero&#123; private String name; private int strength; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getStrength() &#123; return strength; &#125; public void setStrength(int strength) &#123; this.strength = strength; &#125; public Hero(String name, int strength) &#123; this.name = name; this.strength = strength; &#125; @Override public String toString() &#123; return &quot;Hero&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, strength=&quot; + strength + &#x27;&#125;&#x27;; &#125; &#125; 化简 两两合并，只剩一个 使用场景：最大值，最小值，求和，求个数 .reduce((p,x)-&gt;r) p上次的合并结果，X当前元素，r本次合并结果 .reduce(init,(p,x)-&gt;r) .reduce(init,(p,x)-&gt;r,(r1,r2)-&gt;r) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public static void main(String[] args) &#123; Stream&lt;Hero&gt; stream = Stream.of( new Hero(&quot;令孤冲&quot;, 90), new Hero(&quot;风清扬&quot;, 98), new Hero(&quot;独孤求败&quot;, 100), new Hero(&quot;方证&quot;, 92), new Hero(&quot;东方不败&quot;, 98), new Hero(&quot;冲虚&quot;, 90), new Hero(&quot;向问天&quot;, 88), new Hero(&quot;任我行&quot; , 92), new Hero( &quot;不戒&quot;, 88) ); //1.武力值最高的// System.out.println(stream.reduce((h1, h2) -&gt; h1.strength &gt; h2.strength ? h1 : h2));// Hero hero = stream.reduce(new Hero(&quot;-1&quot;, 0), (h1, h2) -&gt; h1.strength &gt; h2.strength ? h1 : h2);// System.out.println(hero); //2.求高手数// System.out.println(stream.map(h -&gt; 1).reduce(0, (a, b) -&gt; a + b));// System.out.println(stream.count());// System.out.println(stream.max(Comparator.comparingInt(Hero::getStrength)));// System.out.println(stream.min(Comparator.comparingInt(Hero::getStrength)));// System.out.println(stream.mapToInt(Hero::getStrength).sum()); //求平均值// System.out.println(stream.mapToInt(Hero::getStrength).average()); &#125; static class Hero&#123; private String name; private int strength; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getStrength() &#123; return strength; &#125; public void setStrength(int strength) &#123; this.strength = strength; &#125; public Hero(String name, int strength) &#123; this.name = name; this.strength = strength; &#125; @Override public String toString() &#123; return &quot;Hero&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, strength=&quot; + strength + &#x27;&#125;&#x27;; &#125; &#125; 收集 将元素收集入容器 .collect(()-&gt;c,(c,x)-&gt;void)12()-&gt;c //创建容器c(c,x)-&gt;void //将元素x 加入容器c 1234567891011121314151617181920212223242526 public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of( &quot;令孤冲&quot;, &quot;风清扬&quot;, &quot;独孤求败&quot;, &quot;方证&quot;, &quot;东方不败&quot;, &quot;冲虚&quot;, &quot;向问天&quot;, &quot;任我行&quot;, &quot;不戒&quot;, &quot;不戒&quot;, &quot;不戒&quot; );// List&lt;String&gt; result = stream.collect(() -&gt; new ArrayList&lt;&gt;(), (list, x) -&gt; list.add(x), (a, b) -&gt; &#123;&#125;); // ArrayList::new () -&gt; new ArrayList&lt;&gt;() //ArrayList::add (list, x) -&gt; list.add(x)// List&lt;String&gt; result = stream.collect(ArrayList::new, ArrayList::add, (a, b) -&gt; &#123;&#125;);// Set&lt;String&gt; result = stream.collect(HashSet::new, Set::add, (a, b) -&gt; &#123;&#125;);// Map&lt;String,Integer&gt; result = stream.collect(HashMap::new, (map,x)-&gt;map.put(x,1), (a, b) -&gt; &#123;&#125;); StringJoiner result = stream.collect(()-&gt;new StringJoiner(&quot;,&quot;), (str,b)-&gt;str.add(b), (a, b) -&gt; &#123;&#125;); System.out.println(result); &#125; 收集器(Collector) 工具类Collectors 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of( &quot;令孤冲&quot;, &quot;风清扬&quot;, &quot;独孤求败&quot;, &quot;方证&quot;, &quot;东方不败&quot;, &quot;冲虚&quot;, &quot;向问天&quot;, &quot;任我行&quot;, &quot;不戒&quot;, &quot;不戒&quot;, &quot;不戒&quot; );// toList(stream);// toSet(stream);// toMap(stream);// joining(stream);// joiningDelimiter(stream); groupBy(stream); &#125; /** * Collectors.toList() * */ private static void toList(Stream&lt;String&gt; stream) &#123; List&lt;String&gt; result = stream.collect(Collectors.toList()); result.forEach(System.out::println); &#125; /** * Collectors.toSet() */ private static void toSet(Stream&lt;String&gt; stream) &#123; Set&lt;String&gt; result = stream.collect(Collectors.toSet()); result.forEach(System.out::println); &#125; /** * Collectors.toMap() * 有重复的key值 需要自定义mergeFunction 不然会报错 * 传入 (k1,k2)-&gt;k1 如果有重复的选择第一个,或者传入你自己的逻辑 */ private static void toMap(Stream&lt;String&gt; stream) &#123; Map&lt;String, Integer&gt; result = stream.collect(Collectors.toMap(x -&gt; x, y -&gt; 1,(k1, k2)-&gt;k1)); result.entrySet().stream().forEach(System.out::println); &#125; /** * Collectors.joining() * @param stream */ private static void joining(Stream&lt;String&gt; stream) &#123; String result = stream.collect(Collectors.joining()); System.out.println(result); &#125; /** * Collectors.joining(CharSequence delimiter) */ private static void joiningDelimiter(Stream&lt;String&gt; stream) &#123; String result = stream.collect(Collectors.joining(&quot;,&quot;)); System.out.println(result); &#125; /* Map 3:new ArrayList([&quot;令孤冲&quot;,&quot;风清扬&quot;, &quot;向问天&quot;,&quot;任我行&quot;]) 4:new ArrayList([ &quot;独孤求败&quot;,&quot;东方不败&quot;]) 2:new ArrayList([ &quot;方证&quot;,&quot;冲虚&quot;,&quot;不戒&quot;]) */ private static void groupBy(Stream&lt;String&gt; stream) &#123;// Map&lt;Integer, List&lt;String&gt;&gt; result = stream.collect(Collectors.groupingBy(String::length, Collectors.toList())); Map&lt;Integer, String&gt; result = stream.collect(Collectors.groupingBy(String::length,Collectors.joining(&quot;,&quot;))); result.entrySet().stream().forEach(System.out::println); &#125; 下游收集器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 public static void main(String[] args) &#123; Stream&lt;Hero&gt; stream = Stream.of( new Hero(&quot;令孤冲&quot;, 90), new Hero(&quot;风清扬&quot;, 98), new Hero(&quot;独孤求败&quot;, 100), new Hero(&quot;方证&quot;, 92), new Hero(&quot;东方不败&quot;, 98), new Hero(&quot;冲虚&quot;, 90), new Hero(&quot;向问天&quot;, 88), new Hero(&quot;任我行&quot; , 92), new Hero( &quot;不戒&quot;, 88) ); CollectorMapping(stream);// CollectorMapToObj();// CollectorCounting(stream);// CollectorMinBy(stream);// CollectorMaxBy(stream);// CollectorSummingInt(stream);// CollectorAveragingDouble(stream);// CollectorReducing(stream); &#125; private static void CollectorMapToObj() &#123; &quot;令狐冲&quot;.chars().mapToObj(x-&gt;Character.toString((char) x)).forEach(System.out::println); &#125; private static void CollectorCounting(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, Long&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), counting())); result.entrySet().forEach(System.out::println); &#125; private static void CollectorMinBy(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, Optional&lt;Hero&gt;&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), minBy(Comparator.comparingInt(Hero::getStrength)))); result.entrySet().forEach(System.out::println); &#125; private static void CollectorMaxBy(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, Optional&lt;Hero&gt;&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), maxBy(Comparator.comparingInt(Hero::getStrength)))); result.entrySet().forEach(System.out::println); &#125; private static void CollectorSummingInt(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, Integer&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), summingInt(Hero::getStrength))); result.entrySet().forEach(System.out::println); &#125; private static void CollectorAveragingDouble(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, Double&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), averagingDouble(Hero::getStrength))); result.entrySet().forEach(System.out::println); &#125; /** * reducing(init,(p,x)-&gt;r) * @param stream */ private static void CollectorReducing(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, Integer&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), mapping(Hero::getStrength, reducing(0, Integer::sum)))); result.entrySet().forEach(System.out::println); &#125; /* 1. mapping(x-&gt;y,dc) 需求：根据名字长度分组 分组后组内只他们的保留武力值 new Hero(&quot;令孤冲&quot;, 90)-&gt;90 dc 下游收集器 down collector */ private static void CollectorMapping(Stream&lt;Hero&gt; stream) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; result = stream.collect(groupingBy(h -&gt; h.getName().length(), mapping(Hero::getStrength, toList()))); result.entrySet().stream().forEach(System.out::println); &#125; static class Hero&#123; private String name; private int strength; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getStrength() &#123; return strength; &#125; public void setStrength(int strength) &#123; this.strength = strength; &#125; public Hero(String name, int strength) &#123; this.name = name; this.strength = strength; &#125; @Override public String toString() &#123; return &quot;Hero&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, strength=&quot; + strength + &#x27;&#125;&#x27;; &#125; &#125; 基本类型流 IntStream LongStream DoubleStream 12345678public static void main(String[] args) &#123; //三种基础流 占用空间小比包装流小 IntStream a= IntStream.of(97,98,9); LongStream b=LongStream.of(1L,2L,3L); DoubleStream c=DoubleStream.of(1.0,2.0,3.0); //包装流 Stream&lt;Integer&gt; d=Stream.of(1,2,3);&#125; 基础流方法 包装流方法 流特性 只能使用一次 两类操作（中间操作 lazy 懒惰，终结操作 eager 迫切） 12345678910111213public static void main(String[] args) &#123; /* Stream流的特性 1.一次使用 2. 两类操作（中间操作 lazy 懒惰，终结操作 eager 迫切） */ Stream&lt;Integer&gt; s1=Stream.of(1,3,5);//水滴 //---------------------------------------------- 阀门 s1 .map(x-&gt;x+1) //水管 .filter(x-&gt;x&lt;=5) //水管 .forEach(System.out::println); //水管 总阀门 2,4&#125; 流总结 并行流 数据量问题：数据量大的时候才建议用并行流 线程会无限增加吗？：跟cpu能处理的线程数有关 收尾的意义： 转不可变集合 StringBuider转String 是否线程安全：不会有线程安全问题 特性： 是否需要收尾（默认收尾） 是否保证顺序（默认保证） 容器是否支持并发（默认不支持） 到达选择哪一种？ Characteristics.CONCURRENT+Characteristics.UNORDERED+线程安全容器 默认+线程不安全容器 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; List&lt;Integer&gt; result = Stream.of(1, 2, 3, 4).parallel().collect(Collector.of( ()-&gt;&#123; System.out.printf(&quot;%-12s %s%n&quot;, threadName(),&quot;创建容器&quot;); return new Vector&lt;Integer&gt;(); &#125;, //创建容器 (list,x)-&gt;&#123; List&lt;Integer&gt; old=new ArrayList&lt;&gt;(list); list.add(x); System.out.printf(&quot;%-12s %s.add(%d)=&gt;%s%n&quot;, threadName(),old,x,list); &#125;, //如何向容器中添加数据 (list1, list2) -&gt; &#123; List&lt;Integer&gt; old=new ArrayList&lt;&gt;(list1); list1.addAll(list2); System.out.printf(&quot;%-12s %s.add(%s)=&gt;%s%n&quot;, threadName(),old,list2,list1); return list1; &#125;, //如何合并两个容器的数据 list -&gt; &#123; System.out.printf(&quot;%-12s finish:%s=&gt;%s%n&quot;, threadName(),list,list); return Collections.unmodifiableList(list); &#125; //收尾 list-&gt;list 不需要转换了 list原样返回 ,Collector.Characteristics.IDENTITY_FINISH //不需要收尾 ,Collector.Characteristics.UNORDERED //不需要保证顺序 ,Collector.Characteristics.CONCURRENT //支持并发 // 特性不写 不支持并发 需要收尾 保证收集顺序 //特性：并发 是否需要收尾，是否保证收集顺序 )); System.out.println(result); result.add(100); System.out.println(result);&#125;private static String threadName() &#123; return Thread.currentThread().getName();&#125; 实现原理Lambda原理基本原理 lambda 表达式是一种语法糖，它仍然会被翻译成类，方法，对象 方法从哪里来：编泽器发现代码中出现了Lambda,就会在当前类中生成private static方法，方法内包含的就是Lambda的逻辑1234//实验代码 for (Method method : C01Lambda1Test.class.getDeclaredMethods()) &#123; System.out.println(method); &#125; 类和对象从哪里来：运行期间动态生成 MethoHandle新的一套反射api MethodHandle的执行权限与上下文相关 原本有权限调用的方法，正常能调用，通过MethodHandle反射也能调用原本没权限调用的方法，正常不能调用，MethodHandle反射也调用不了 12-Djdk.invoke.LambdaMetafactory.dumpProxyclassFiles-Djdk.internal.lambda.dumpProxyClasses 123456789101112131415161718192021222324252627282930313233343536import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;import java.lang.reflect.Method;import java.util.function.BinaryOperator;public class C01Lambda1Test &#123; public static void main(String[] args) throws Throwable &#123; BinaryOperator&lt;Integer&gt; lambda=(a, b)-&gt;a+b; for (Method method : C01Lambda1Test.class.getDeclaredMethods()) &#123; System.out.println(method); &#125; MethodHandle mh1 = MethodHandles.lookup().findStatic(C01Lambda1Test.class, &quot;lambda$test1$2&quot;, MethodType.methodType(Integer.class, Integer.class, Integer.class)); System.out.println(mh1.invoke(1,2)); MethodHandle mh2 = MethodHandles.lookup().findVirtual(MyLambda.class, &quot;apply&quot;, MethodType.methodType(Integer.class, Integer.class, Integer.class)); System.out.println(mh2.invoke(new MyLambda(),3,4)); &#125; static final class MyLambda implements BinaryOperator&lt;Integer&gt;&#123; private MyLambda()&#123;&#125; @Override public Integer apply(Integer a, Integer b) &#123; return lambda$test1$2(a,b); &#125; &#125; static Integer lambda$test1$2(Integer a,Integer b)&#123; return a+b; &#125;//控制台打印如下//public void com.github.ed.C01Lambda1Test.test1()//private static java.lang.Integer com.github.ed.C01Lambda1Test.lambda$test1$0(java.lang.Integer,java.lang.Integer)//java.lang.Integer com.github.ed.C01Lambda1Test.lambda$test1$2(java.lang.Integer,java.lang.Integer) 运行时生成的代理类如下 LambdaMetafactory caller：接收一个 Lookup 对象，它要有访问生成的类的权限； interfaceMethodName：接口方法名，也就是可以写成 Lambda 表达式的函数式接口中的方法名； factoryType：工厂类型，创建生成的类对象的工厂方法对应的 MethodType。以假定的生成类 MyLambda 为例，如果需要使用一个工厂方法来构建 MyLambda 对象，这个工厂方法不需要任何参数，返回值类型是 BinaryOperator； interfaceMethodType：接口方法类型，指函数式接口中的方法对应的 MethodType。以使用的BinaryOperator 为例，其内部的方法都使用了泛型，因此这些参数和返回值类型应该是 Object； implementation：生成的方法的MethodHandle，这里就是 lambda$test1$2 对应的 MethodHandle； dynamicMethodType：动态方法类型，这里指的是生成类 MyLambda 中 apply() 方法对应的 MethodType。 12345678910111213141516171819202122232425262728293031323334353637383940import java.lang.invoke.CallSite;import java.lang.invoke.LambdaMetafactory;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;import java.util.function.BinaryOperator;public class C01Lambda1Test &#123; public static void main(String[] args) throws Throwable &#123; MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle impl = lookup.findStatic(C01Lambda1Test.class, &quot;lambda$test1$2&quot;, MethodType.methodType(Integer.class, Integer.class, Integer.class)); //内部：生成函数所需要的类 ASM CallSite cs = LambdaMetafactory.metafactory( lookup, //1.lookup &quot;apply&quot;, //2.接口方法名 MethodType.methodType(BinaryOperator.class), //3.工厂类型，创建生成的类对象的工厂方法对应的 MethodType。以假定的生成类 MyLambda 为例，如果需要使用一个工厂方法来构建 MyLambda 对象，这个工厂方法不需要任何参数，返回值类型是 BinaryOperator MethodType.methodType(Object.class, Object.class, Object.class), //4.接口方法类型，指函数式接口中的方法对应的 MethodType impl, //5.生成的方法的 MethodHandle，这里就是 lambda$test1$2() 对应的 MethodHandle MethodType.methodType(Integer.class, Integer.class, Integer.class) //6.动态方法类型，这里指的是生成类 MyLambda 中 apply() 方法对应的 MethodType ); // BinaryOperator factory()&#123;return new MyLambda();&#125; MethodHandle mh = cs.getTarget();//函数对象工厂方法 BinaryOperator&lt;Integer&gt; invoke = (BinaryOperator&lt;Integer&gt;) mh.invoke(); System.out.println(invoke.apply(5, 6)); &#125; static final class MyLambda implements BinaryOperator&lt;Integer&gt;&#123; private MyLambda()&#123;&#125; @Override public Integer apply(Integer a, Integer b) &#123; return lambda$test1$2(a,b); &#125; &#125; static Integer lambda$test1$2(Integer a,Integer b)&#123; return a+b; &#125;&#125; 执行时机 通过javap -c -v xxx.class反编译查看 执行到 Lambda 表达式时会执行 invokedynamic 虚拟机指令，之后就会去执行 LambdaMetafactory.metafactory()方法生成函数对象 方法引用原理 方法引用是一种语法糖，它仍然会被翻译成类、对象、方法 方法从哪来 类、对象从哪来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.invoke.CallSite;import java.lang.invoke.LambdaMetafactory;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;import java.util.function.Function;public class C02MethReference &#123; public static void main(String[] args) throws Throwable &#123; Function&lt;Student, String&gt; func = Student::getName;// stu-&gt;stu.getName MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle impl = lookup.findVirtual(Student.class, &quot;getName&quot;, MethodType.methodType(String.class)); CallSite cs = LambdaMetafactory.metafactory( lookup, &quot;apply&quot;, MethodType.methodType(Function.class), MethodType.methodType(Object.class, Object.class), impl, MethodType.methodType(String.class, Student.class) ); MethodHandle methodHandle = cs.getTarget(); Function&lt;Student, String&gt; invoke = (Function&lt;Student, String&gt;) methodHandle.invoke(); Student student = new Student(); student.name=&quot;张三&quot;; System.out.println(invoke.apply(student)); &#125; static class MyMethReference implements Function&lt;Student,String&gt;&#123; @Override public String apply(Student student) &#123; return student.getName(); &#125; &#125; static class Student&#123; private String name; public String getName() &#123; return name; &#125; &#125;&#125; 闭包原理闭包只是 Lambda 表达式中引用了外部的变量，因此闭包的原理与前文中 Lambda 表达式的原理基本一致，同样需要生成类、对象和方法 引用外部变量可能有 3 中情况： 局部变量 静态变量 成员变量 局部变量 123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Method;import java.util.function.BinaryOperator;public class C03Closure &#123; public static void main(String[] args) &#123; int c=10; BinaryOperator&lt;Integer&gt; lambda=(a,b)-&gt;a+b+c; for (Method method : C03Closure.class.getDeclaredMethods()) &#123; System.out.println(method); &#125; &#125; static final class MyClosure implements BinaryOperator &#123; private final int arg$1; private MyClosure(int var1) &#123; this.arg$1 = var1; &#125; private static BinaryOperator get$Lambda(int var0) &#123; return new MyClosure(var0); &#125; public Object apply(Object var1, Object var2) &#123; return C03Closure.lambda$main$3(this.arg$1, (Integer)var1, (Integer)var2); &#125; &#125; private static Integer lambda$main$3(int c, Integer a, Integer b)&#123; return a+b+c; &#125;&#125; 静态变量 12345678910111213141516171819202122232425262728import java.lang.reflect.Method;import java.util.function.BinaryOperator;public class C03Closure &#123; static int c=10; public static void main(String[] args) &#123; BinaryOperator&lt;Integer&gt; lambda=(a,b)-&gt;a+b+c; for (Method method : C03Closure.class.getDeclaredMethods()) &#123; System.out.println(method); &#125; &#125; static final class MyClosure implements BinaryOperator &#123; private MyClosure() &#123; &#125; public Object apply(Object var1, Object var2) &#123; return C03Closure.lambda$main$3((Integer)var1, (Integer)var2); &#125; &#125; private static Integer lambda$main$3(Integer a, Integer b)&#123; return a+b+c; &#125;&#125; 成员变量 1234567891011121314151617181920212223242526272829303132333435363738import java.lang.reflect.Method;import java.util.function.BinaryOperator;public class C03Closure &#123; int c=10; BinaryOperator&lt;Integer&gt; lambda=(a,b)-&gt;a+b+c; public static void main(String[] args) &#123; C03Closure c03Closure = new C03Closure(); for (Method method : C03Closure.class.getDeclaredMethods()) &#123; System.out.println(method); &#125; &#125; static final class MyClosure implements BinaryOperator &#123; private final C03Closure arg$1; private MyClosure(C03Closure var1) &#123; this.arg$1 = var1; &#125; private static BinaryOperator get$Lambda(C03Closure var0) &#123; return new MyClosure(var0); &#125; public Object apply(Object var1, Object var2) &#123; return this.arg$1.lambda$new$3((Integer)var1, (Integer)var2); &#125; &#125; private Integer lambda$new$3(Integer a, Integer b) &#123; return a+b+this.c; &#125;&#125; Stream切分12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.util.Arrays;import java.util.List;import java.util.Spliterator;import java.util.concurrent.CompletableFuture;import java.util.stream.StreamSupport;public class C04Spliterator &#123; public static void main(String[] args) throws IOException &#123; List&lt;Integer&gt; list=Arrays.asList(1,2,3,4,5,6,7,8,9); Integer[]array=&#123;1,2,3,4,5,6,7,8,9&#125;;/* Stream&lt;Integer&gt; s1 =list.stream(); Stream&lt;Integer&gt;s2= Arrays.stream(array);*/ Spliterator&lt;Integer&gt; sp1 = list.spliterator();/* sp1.tryAdvance(System.out::println); sp1.tryAdvance(System.out::println); sp1.tryAdvance(System.out::println); System.out.println(&quot;=============&quot;); sp1.forEachRemaining(System.out::println);*/ Spliterator&lt;Integer&gt; sp2 = sp1.trySplit(); Spliterator&lt;Integer&gt; sp3 = sp2.trySplit(); /* System.out.println(&quot;s1:&quot;); sp1.forEachRemaining(System.out::println); System.out.println(&quot;s2:&quot;); sp2.forEachRemaining(System.out::println); System.out.println(&quot;s3:&quot;); sp3.forEachRemaining(System.out::println);*/ CompletableFuture.supplyAsync( ()-&gt; StreamSupport.stream(sp1,false).reduce(0,Integer::sum) ).thenAccept(System.out::println); CompletableFuture.supplyAsync( ()-&gt; StreamSupport.stream(sp2,false).reduce(0,Integer::sum) ).thenAccept(System.out::println); CompletableFuture.supplyAsync( ()-&gt; StreamSupport.stream(sp3,false).reduce(0,Integer::sum) ).thenAccept(System.out::println); System.in.read(); &#125;&#125; 参考黑马程序员Java函数式编程全套视频教程，Lambda表达式、Stream流、函数式编程一套全通关","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"https://erdong27.github.io/tags/Lambda/"}]},{"title":"泛型与通配符","slug":"泛型与通配符","date":"2024-07-25T06:05:12.000Z","updated":"2024-07-25T06:05:12.000Z","comments":true,"path":"2024/07/25/泛型与通配符/","permalink":"https://erdong27.github.io/2024/07/25/%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/","excerpt":"","text":"什么是泛型？泛型有什么用？泛型是JDK5引入的新特性，可以增强代码的可读性与稳定性。 可以在编译期间进行类型检查，通过指定泛型限制传入的对象类型List&lt;Integer&gt; list=new ArrayList&lt;&gt;();这段代码表明list只能传入Integer类型,传入其他类型就会出现错误 泛型使用方式可以作用在类，方法，接口 泛型类 1234567891011121314151617//T 可以是任意的你想要的标识 //默认约定使用比较多的是T,E,K,V//T（Type）是最常用的泛型类型参数，用来表示任意类型。//E（Element）常用于集合框架，表示集合中的元素类型。//K（Key）和V（Value）常用于键值对，分别表示键的类型和值的类型。public class Generic&lt;T&gt; &#123; private final T type; public Generic(T type) &#123; this.type = type; &#125; public T getType()&#123; return type; &#125; &#125; 泛型方法 1234567891011121314public static &lt;T&gt; void printArray(T[] array) &#123; if (array == null) &#123; throw new IllegalArgumentException(&quot;Array must not be null&quot;); &#125; for (T element : array) &#123; System.out.println(element); &#125;&#125; public static void main(String[] args) &#123; // 创建一个整数数组 Integer[] numbers = &#123;1, 2, 3, 4, 5&#125;; // 调用printArray方法打印整数数组 printArray(numbers);&#125; 泛型接口 1234567891011121314151617181920public interface GenericInterface&lt;K,V&gt; &#123; V getKey(K key);&#125;class GenericClass&lt;K,V&gt; implements GenericInterface&lt;String,String&gt; &#123; @Override public String getKey(String key) &#123; return key+&quot; world&quot;; &#125; public static void main(String[] args) &#123; GenericInterface&lt;String,String&gt; genericInterface=new GenericClass&lt;String,String&gt;(); System.out.println(genericInterface.getKey(&quot;hello&quot;)); &#125;&#125; 什么是泛型擦除机制？Java编译器在编译期间会将所有的泛型都擦除掉 泛型为T的变为Object,T extends xxx变为限定类型xxx 编写的代码如下 12345678public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); Class&lt;? extends List&gt; clazz = list.getClass(); Method addMethod = clazz.getDeclaredMethod(&quot;add&quot;, Object.class); addMethod.invoke(list, &quot;hello&quot;); System.out.println(list);&#125; 使用javac xxx.java编译之后的class如下 123456789public static void main(String[] var0) throws Exception &#123; ArrayList var1 = new ArrayList(); var1.add(1); Class var2 = var1.getClass(); //利用反射调用add方法将字符串加入到list里面去 绕过编译器检查 Method var3 = var2.getDeclaredMethod(&quot;add&quot;, Object.class);//这里的Object.class指定的入参数据类型 这里必须指定为Object.class 间接证明泛型被擦除后都是Object.class var3.invoke(var1, &quot;hello&quot;); System.out.println(var1);&#125; 可以看到String在编译成class文件之后被擦除掉了 为什么要擦除？ 使用泛型的时候可以进行类型检查 如果不使用泛型，而直接使用Object类，那么就必须要进行强制类型转换，代码可读性低 泛型可以使用自己指定的限定类型 T extends xxx T super xxx 什么是桥方法？桥方法(Bridge Method) 用于继承泛型类时保证多态。桥方法由编译器生成 12345678910111213141516171819202122// 泛型类public class GenericClass&lt;T&gt; &#123; public void method(T param) &#123; System.out.println(&quot;Generic method with type: &quot; + param.getClass().getName()); System.out.println(&quot;Generic method with type: &quot; + param); &#125;&#125;// 子类，没有使用泛型参数public class ConcreteClass extends GenericClass&#123; // 这里没有显式声明method方法，但编译器会生成桥方法 public static void main(String[] args) &#123; ConcreteClass concreteClass = new ConcreteClass(); concreteClass.method(&quot;Hello, World!&quot;); // 调用桥方法 &#125;&#125; 控制台打印如下： 泛型的限制 只能声明 不能实例化 即不能new T() 12345678910111213141516171819public class GenericClass&lt;T&gt; &#123; private T value; public void setValue(T value) &#123; this.value = value; &#125; public T getValue() &#123; return value; &#125; // 尝试实例化类型参数T的错误用法 public void incorrectInstantiation() &#123; T instance = new T(); // 错误：类型T不是直接的类或接口类型 &#125;&#125; 泛型参数不能是基本数据类型。基本类型不是Object.class的子类 不能实例化泛型参数数组 12345678public void incorrectArrayInstantiation() &#123; T[] array = new T[10]; // 错误：无法创建泛型类型的数组&#125;// 尝试实例化类型参数T的错误用法public static void main(String[] args) &#123; GenericClass&lt;String&gt; genericClass = new GenericClass&lt;&gt;(); genericClass.incorrectArrayInstantiation(); // 编译错误&#125; 不能实例化泛型数组 1234567public class GenericClass&lt;T&gt; &#123; private T[] items; // 错误：不能直接实例化泛型数组 public GenericClass() &#123; items = new T[10]; // 编译错误：类型T不是直接的类或接口类型 &#125;&#125; 泛型无法使用 instanceof 和 getClass() 进行类型判断 1234567891011121314151617181920212223242526272829303132333435public class GenericClass&lt;T&gt; &#123; private T data; public GenericClass(T data) &#123; this.data = data; &#125; // 尝试使用instanceof操作符，这将导致编译错误 public boolean canUseInstanceOf() &#123; return data instanceof T; // 错误：类型参数T在运行时不是一个有效的类型 &#125; // 尝试获取泛型类型的Class对象，这将导致编译错误 public Class&lt;T&gt; getClassOfT() &#123; return (Class&lt;T&gt;) data.getClass(); // 错误：类型参数T在运行时不是一个有效的类型 &#125; public static void main(String[] args) &#123; GenericClass&lt;String&gt; stringDemo = new GenericClass&lt;&gt;(&quot;Hello, World!&quot;); // 下面的调用将导致编译错误// boolean canUseInstanceOf = stringDemo.canUseInstanceOf();// Class&lt;T&gt; classOfT = stringDemo.getClassOfT(); // 正确的使用方式 String data = stringDemo.data; boolean isInstanceOfString = data instanceof String; // 正确：data是String类型 System.out.println(&quot;Is instance of String? &quot; + isInstanceOfString); Class&lt;?&gt; clazz = data.getClass(); // 正确：getClass()返回Object的Class对象 System.out.println(&quot;Class of data: &quot; + clazz.getName()); &#125;&#125; 不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突 123456789101112131415161718192021222324interface GenericInterface&lt;T&gt; &#123; void method(T param);&#125;// 第一个实现，使用Integer类型class FirstImplementation implements GenericInterface&lt;Integer&gt; &#123; @Override public void method(Integer param) &#123; System.out.println(&quot;FirstImplementation with Integer: &quot; + param); &#125;&#125;// 第二个实现，使用String类型class SecondImplementation implements GenericInterface&lt;String&gt; &#123; @Override public void method(String param) &#123; System.out.println(&quot;SecondImplementation with String: &quot; + param); &#125;&#125;// 尝试实现两个泛型接口的类class DoubleImplementation extends FirstImplementation implements GenericInterface&lt;Double&gt; &#123; &#125; 不能使用 static 修饰泛型变量 通配符什么是通配符？有什么作用？因为泛型类型是固定的，有些场景下使用起来不灵活，通配符允许类型参数变化，解决泛型无法协变的问题 1234//限制类型为A的子类&lt;? extends A&gt;//限制类型为B的父类&lt;? super B&gt; 通配符 ？和常用的泛型 T 之间有什么区别？ T 可以用于声明变量或常量而 ? 不行。 T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。 1234567891011//用于声明泛型类public class Box&lt;T&gt; &#123; //泛型方法 public static &lt;T&gt; void print(T element) &#123; System.out.println(element); &#125; public static &lt;T&gt; void add(List&lt;? super T&gt; list, T element) &#123; list.add(element); &#125;&#125; T在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。 无界通配符无界通配符可以接收任何泛型类型数据，用于实现不依赖于具体类型参数的简单方法，可以捕获参数类型并交由泛型方法进行处理。 123void testMethod(Person&lt;?&gt; p) &#123; // 泛型方法自行处理&#125; 12345//持有某种特定类型的List,不知道具体是哪种类型。添加元素会报错List&lt;?&gt; list1 = new ArrayList&lt;&gt;();list1.add(&quot;Hello&quot;);//报错List list2 = new ArrayList&lt;&gt;();list2.add(&quot;World&quot;);//警告 上边界通配符上边界通配符 extends 可以实现泛型的向上转型即传入的类型实参必须是指定类型的子类型 1List&lt;? extends T&gt; list //限制必须是T的子类 下边界通配符1List&lt;? super T&gt; list //限制必须是T的父类 ? extends xxx 和 ? super xxx 有什么区别?123456789 //只能用来读取数据 //因为编译器无法保证添加的对象是列表所能接受的确切类型或其超类 List&lt;? extends Number&gt; numberList = new ArrayList&lt;Integer&gt;(); numberList.get(0); numberList.add(1);//会报错//只能用来添加数据到集合中 因为编译器无法在运行时检查添加的对象是否是确切的类型或其子类 List&lt;? super Integer&gt; integerList = new ArrayList&lt;Integer&gt;();integerList.add(1);integerList.get(0)//会报错 T extends xxx 和 ? extends xxx 又有什么区别？T extends xxx 用于定义泛型类和方法 擦除后为xxx类型 ? extends xxx 用于声明方法形参，接收 xxx 和其子类型 参考Java 基础 一文搞懂泛型","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"},{"name":"generic","slug":"generic","permalink":"https://erdong27.github.io/tags/generic/"}]},{"title":"vite配置环境变量","slug":"vite配置环境变量","date":"2024-07-19T15:13:28.000Z","updated":"2024-07-19T15:13:28.000Z","comments":true,"path":"2024/07/19/vite配置环境变量/","permalink":"https://erdong27.github.io/2024/07/19/vite%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"创建环境变量：在项目的根目录创建.env.development 和.env.prodution两个文件 分别为开发环境和生产环境(必须以.env.开头) 在环境变量文件分别写对应环境变量，变量必须以VITE_开头 开发环境配置和访问环境变量 访问变量前 需要在package.json 的dev中配置mode 这个名字跟.env.后面的一致，若名字是.env.development则无需配置 使用import.meta.env+文件中定义的名字访问 启动本地环境，访问对应页面时，会打印以下信息 在vite.config.ts中访问环境变量：使用vite的loadEnv插件，需要将vite配置包裹在一个函数中，使用结构将当前mode模式拿到，如下所示： 在生产环境访问环境变量 打包项目，执行npm run build，生成了dist文件夹； 需要全局安装插件，npm install http-server -g，在dist文件夹打开终端，输入http-server -p 9091，即可启动一个服务查看打包后的项目 访问127.0.0.1:9091,可以看到控制台打印的是生产的环境变量，说明生效了","categories":[{"name":"VUE","slug":"VUE","permalink":"https://erdong27.github.io/categories/VUE/"}],"tags":[{"name":"VITE","slug":"VITE","permalink":"https://erdong27.github.io/tags/VITE/"},{"name":"VUE","slug":"VUE","permalink":"https://erdong27.github.io/tags/VUE/"}]},{"title":"Redis网络模型","slug":"Redis网络模型","date":"2024-07-17T11:40:54.000Z","updated":"2024-07-17T11:40:54.000Z","comments":true,"path":"2024/07/17/Redis网络模型/","permalink":"https://erdong27.github.io/2024/07/17/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"[!Note] 本文基于Redis6.2.6 Redis网络模型 用户空间和内核空间 阻塞IO 非阻塞IO IO多路复用IO多路复用 IO多路复用-select IO多路复用-poll IO多路复用-epoll IO多路复用-事件通知机制 IO多路复用-web服务流程 总结 信号驱动IO 异步IO 同步和异步 Redis网络模型Redis到底是单线程还是多线程？ 为什么Redis要选择单线程？ Redis网络模型api Redis网络模型源码 Redis网络模型单线程流程图 Redis网络模型多线程流程图 本文参考链接","categories":[{"name":"数据库","slug":"数据库","permalink":"https://erdong27.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://erdong27.github.io/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"https://erdong27.github.io/tags/NOSQL/"}]},{"title":"RESP协议","slug":"RESP协议","date":"2024-07-17T11:40:23.000Z","updated":"2024-07-17T11:40:23.000Z","comments":true,"path":"2024/07/17/RESP协议/","permalink":"https://erdong27.github.io/2024/07/17/RESP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"[!Note] 本文基于Redis6.2.6 RESP协议 RESP协议 RESP协议-数据类型 本文参考链接","categories":[{"name":"数据库","slug":"数据库","permalink":"https://erdong27.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://erdong27.github.io/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"https://erdong27.github.io/tags/NOSQL/"}]},{"title":"Redis内存策略","slug":"Redis内存策略","date":"2024-07-17T11:40:06.000Z","updated":"2024-07-17T11:40:06.000Z","comments":true,"path":"2024/07/17/Redis内存策略/","permalink":"https://erdong27.github.io/2024/07/17/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/","excerpt":"","text":"[!Note] 本文基于Redis6.2.6 Redis内存策略 Redis内存回收 过期策略 过期策略-DB结构 过期策略-惰性删除 过期策略-周期删除 SLOW模式与FAST模式 总结 淘汰策略内存淘汰 八种淘汰策略 LFU与LFU的淘汰算法 执行淘汰流程图 本文参考链接","categories":[{"name":"数据库","slug":"数据库","permalink":"https://erdong27.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://erdong27.github.io/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"https://erdong27.github.io/tags/NOSQL/"}]},{"title":"Redis数据结构","slug":"Redis数据结构","date":"2024-07-16T11:21:43.000Z","updated":"2024-07-16T11:21:43.000Z","comments":true,"path":"2024/07/16/Redis数据结构/","permalink":"https://erdong27.github.io/2024/07/16/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"[!Note] 本文基于Redis6.2.6 Redis数据结构动态字符串SDS IntSetInSet原理 IntSet新增流程 InSet升级流程 总结 DictDict组成 Dict的扩容 Dict的rehash 总结 ZipListZipList定义与组成 ZipListEntry Encoding编码 ZipList的连锁更新问题 总结 QuickList 源码 内存结构图 总结 SkipListSkipList 源码 总结 RedisObjectRedisObject Redis的编码方式 五种数据结构 五种数据结构String raw编码 embstr编码 INT编码 查看编码格式命令1object encoding key List遇到的问题 不同版本采取的编码 内存结构图 Set特点 HT编码(Dict)与IntSet编码 源码 set-max-intset-entries默认值 内存结构图 ZSetSkipList与HT(Dict) 内存结构图 使用ZipList结构的条件 源码 使用ZipList时排序问题 Hashhash结构特点，与ZSet的区别 内存结构图 源码 命令设置ZipList个数与数量限制 本文参考链接","categories":[{"name":"数据库","slug":"数据库","permalink":"https://erdong27.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://erdong27.github.io/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"https://erdong27.github.io/tags/NOSQL/"}]},{"title":"cglib原理","slug":"cglib原理","date":"2024-07-15T15:08:13.000Z","updated":"2024-07-15T15:08:13.000Z","comments":true,"path":"2024/07/15/cglib原理/","permalink":"https://erdong27.github.io/2024/07/15/cglib%E5%8E%9F%E7%90%86/","excerpt":"","text":"CGLIB代理原理-MethodProxyTarget-目标类1234567891011121314151617package com.github.ed.test.test8;//目标类public class Target &#123; public void save()&#123; System.out.println(&quot;save()&quot;); &#125; public void save(int i)&#123; System.out.println(&quot;save(int)&quot;); &#125; public void save(long l)&#123; System.out.println(&quot;save(long)&quot;); &#125;&#125; Prxoy-代理类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.github.ed.test.test8;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;//代理类public class Prxoy extends Target&#123; private final MethodInterceptor methodInterceptor; public Prxoy(MethodInterceptor methodInterceptor) &#123; this.methodInterceptor=methodInterceptor; &#125; static Method save0; static Method save1; static Method save2; static MethodProxy save0Super; static MethodProxy save1Super; static MethodProxy save2Super; static &#123; try &#123; save0 =Target.class.getMethod(&quot;save&quot;); save1 =Target.class.getMethod(&quot;save&quot;,int.class); save2 =Target.class.getMethod(&quot;save&quot;,long.class); save0Super =MethodProxy.create(Target.class,Prxoy.class,&quot;()V&quot;,&quot;save&quot;,&quot;saveSuper&quot;); save1Super =MethodProxy.create(Target.class,Prxoy.class,&quot;(I)V&quot;,&quot;save&quot;,&quot;saveSuper&quot;); save2Super =MethodProxy.create(Target.class,Prxoy.class,&quot;(J)V&quot;,&quot;save&quot;,&quot;saveSuper&quot;); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125; &#125; public void saveSuper()&#123; super.save(); &#125; public void saveSuper(int i)&#123; super.save(i); &#125; public void saveSuper(long j)&#123; super.save(j); &#125; public void save()&#123; try &#123; methodInterceptor.intercept(this, save0, new Object[0], save0Super); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125;// super.save(); &#125; public void save(int i)&#123; try &#123; methodInterceptor.intercept(this, save1, new Object[]&#123;i&#125;, save1Super); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; public void save(long j)&#123; try &#123; methodInterceptor.intercept(this, save2, new Object[]&#123;j&#125;, save2Super); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 测试12345678910111213141516171819202122package com.github.ed.test.test8;public class A14 &#123; public static void main(String[] args) &#123; Target target=new Target(); Prxoy prxoy=new Prxoy((p, method, args1, methodProxy) -&gt; &#123; System.out.println(&quot;before...&quot;);// Object result = method.invoke(target, args1);// Object result = methodProxy.invoke(target, args1);//内部无反射 结合目标方法 Object result = methodProxy.invokeSuper(p, args1);//内部无反射 结合代理方法 return result; &#125;); prxoy.save(); prxoy.save(1); prxoy.save(2L); System.out.println(A14.class.getName()); System.in.read(); &#125;&#125; MethodProxy原理1.用arthas 查看,已经生成了两个代理类，一个目标类的FastClass代理类，一个代理类的FastClass代理类 jad com.github.ed.test.test8.Prxoy$$FastClassByCGLIB$$a601950d查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229package com.github.ed.test.test8;import com.github.ed.test.test8.Prxoy;import java.lang.reflect.InvocationTargetException;import org.springframework.cglib.core.Signature;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.reflect.FastClass;//代理类的代理类public class Prxoy$$FastClassByCGLIB$$a601950dextends FastClass &#123; //根据方法索引调用方法 @Override public Object invoke(int n, Object object, Object[] objectArray) throws InvocationTargetException &#123; Prxoy prxoy = (Prxoy)object; try &#123; switch (n) &#123; case 0: &#123; prxoy.save(((Number)objectArray[0]).longValue()); return null; &#125; case 1: &#123; prxoy.save(); return null; &#125; case 2: &#123; prxoy.save(((Number)objectArray[0]).intValue()); return null; &#125; case 3: &#123; prxoy.saveSuper(((Number)objectArray[0]).intValue()); return null; &#125; case 4: &#123; prxoy.saveSuper(); return null; &#125; case 5: &#123; prxoy.saveSuper(((Number)objectArray[0]).longValue()); return null; &#125; case 6: &#123; return new Boolean(prxoy.equals(objectArray[0])); &#125; case 7: &#123; return prxoy.toString(); &#125; case 8: &#123; return new Integer(prxoy.hashCode()); &#125; &#125; &#125; catch (Throwable throwable) &#123; throw new InvocationTargetException(throwable); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125; public Prxoy$$FastClassByCGLIB$$a601950d(Class clazz) &#123; super(clazz); &#125; @Override public Object newInstance(int n, Object[] objectArray) throws InvocationTargetException &#123; try &#123; switch (n) &#123; case 0: &#123; return new Prxoy((MethodInterceptor)objectArray[0]); &#125; &#125; &#125; catch (Throwable throwable) &#123; throw new InvocationTargetException(throwable); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125; @Override public int getIndex(Class[] classArray) &#123; Class[] classArray2 = classArray; switch (classArray.length) &#123; case 1: &#123; classArray2 = classArray2; if (!classArray2[0].getName().equals(&quot;org.springframework.cglib.proxy.MethodInterceptor&quot;)) break; return 0; &#125; &#125; return -1; &#125; @Override public int getIndex(String string, Class[] classArray) &#123; String string2 = string; Class[] classArray2 = classArray; block0 : switch (string2.hashCode()) &#123; case -1776922004: &#123; if (!string2.equals(&quot;toString&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 7; &#125; &#125; break; &#125; case -1295482945: &#123; if (!string2.equals(&quot;equals&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 1: &#123; classArray2 = classArray2; if (!classArray2[0].getName().equals(&quot;java.lang.Object&quot;)) break block0; return 6; &#125; &#125; break; &#125; case 3522941: &#123; if (!string2.equals(&quot;save&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 1; &#125; case 1: &#123; classArray2 = classArray2; String string3 = classArray2[0].getName(); switch (string3.hashCode()) &#123; case 104431: &#123; if (!string3.equals(&quot;int&quot;)) break block0; return 2; &#125; case 3327612: &#123; if (!string3.equals(&quot;long&quot;)) break block0; return 0; &#125; &#125; break block0; &#125; &#125; break; &#125; case 147696667: &#123; if (!string2.equals(&quot;hashCode&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 8; &#125; &#125; break; &#125; case 173089790: &#123; if (!string2.equals(&quot;saveSuper&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 4; &#125; case 1: &#123; classArray2 = classArray2; String string4 = classArray2[0].getName(); switch (string4.hashCode()) &#123; case 104431: &#123; if (!string4.equals(&quot;int&quot;)) break block0; return 3; &#125; case 3327612: &#123; if (!string4.equals(&quot;long&quot;)) break block0; return 5; &#125; &#125; break block0; &#125; &#125; break; &#125; &#125; return -1; &#125; //根据方法签名获取方法索引 @Override public int getIndex(Signature signature) &#123; String string = ((Object)signature).toString(); switch (string.hashCode()) &#123; case -2073951957: &#123; if (!string.equals(&quot;save(I)V&quot;)) break; return 2; &#125; case -2073950996: &#123; if (!string.equals(&quot;save(J)V&quot;)) break; return 0; &#125; case -1737748809: &#123; if (!string.equals(&quot;saveSuper()V&quot;)) break; return 4; &#125; case 1826985398: &#123; if (!string.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) break; return 6; &#125; case 1872760024: &#123; if (!string.equals(&quot;save()V&quot;)) break; return 1; &#125; case 1913648695: &#123; if (!string.equals(&quot;toString()Ljava/lang/String;&quot;)) break; return 7; &#125; case 1964391212: &#123; if (!string.equals(&quot;saveSuper(I)V&quot;)) break; return 3; &#125; case 1964392173: &#123; if (!string.equals(&quot;saveSuper(J)V&quot;)) break; return 5; &#125; case 1984935277: &#123; if (!string.equals(&quot;hashCode()I&quot;)) break; return 8; &#125; &#125; return -1; &#125; @Override public int getMaxIndex() &#123; return 8; &#125;&#125; jad com.github.ed.test.test8.Target$$FastClassByCGLIB$$20120544查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.github.ed.test.test8;import com.github.ed.test.test8.Target;import java.lang.reflect.InvocationTargetException;import org.springframework.cglib.core.Signature;import org.springframework.cglib.reflect.FastClass;//目标类的代理类public class Target$$FastClassByCGLIB$$20120544extends FastClass &#123; @Override public Object invoke(int n, Object object, Object[] objectArray) throws InvocationTargetException &#123; Target target = (Target)object; try &#123; switch (n) &#123; case 0: &#123; target.save(((Number)objectArray[0]).longValue()); return null; &#125; case 1: &#123; target.save(((Number)objectArray[0]).intValue()); return null; &#125; case 2: &#123; target.save(); return null; &#125; case 3: &#123; return new Boolean(target.equals(objectArray[0])); &#125; case 4: &#123; return target.toString(); &#125; case 5: &#123; return new Integer(target.hashCode()); &#125; &#125; &#125; catch (Throwable throwable) &#123; throw new InvocationTargetException(throwable); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125; public Target$$FastClassByCGLIB$$20120544(Class clazz) &#123; super(clazz); &#125; @Override public Object newInstance(int n, Object[] objectArray) throws InvocationTargetException &#123; try &#123; switch (n) &#123; case 0: &#123; return new Target(); &#125; &#125; &#125; catch (Throwable throwable) &#123; throw new InvocationTargetException(throwable); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125; @Override public int getIndex(Class[] classArray) &#123; Class[] classArray2 = classArray; switch (classArray.length) &#123; case 0: &#123; return 0; &#125; &#125; return -1; &#125; @Override public int getIndex(String string, Class[] classArray) &#123; String string2 = string; Class[] classArray2 = classArray; block0 : switch (string2.hashCode()) &#123; case -1776922004: &#123; if (!string2.equals(&quot;toString&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 4; &#125; &#125; break; &#125; case -1295482945: &#123; if (!string2.equals(&quot;equals&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 1: &#123; classArray2 = classArray2; if (!classArray2[0].getName().equals(&quot;java.lang.Object&quot;)) break block0; return 3; &#125; &#125; break; &#125; case 3522941: &#123; if (!string2.equals(&quot;save&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 2; &#125; case 1: &#123; classArray2 = classArray2; String string3 = classArray2[0].getName(); switch (string3.hashCode()) &#123; case 104431: &#123; if (!string3.equals(&quot;int&quot;)) break block0; return 1; &#125; case 3327612: &#123; if (!string3.equals(&quot;long&quot;)) break block0; return 0; &#125; &#125; break block0; &#125; &#125; break; &#125; case 147696667: &#123; if (!string2.equals(&quot;hashCode&quot;)) break; classArray2 = classArray2; switch (classArray2.length) &#123; case 0: &#123; return 5; &#125; &#125; break; &#125; &#125; return -1; &#125; @Override public int getIndex(Signature signature) &#123; String string = ((Object)signature).toString(); switch (string.hashCode()) &#123; case -2073951957: &#123; if (!string.equals(&quot;save(I)V&quot;)) break; return 1; &#125; case -2073950996: &#123; if (!string.equals(&quot;save(J)V&quot;)) break; return 0; &#125; case 1826985398: &#123; if (!string.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) break; return 3; &#125; case 1872760024: &#123; if (!string.equals(&quot;save()V&quot;)) break; return 2; &#125; case 1913648695: &#123; if (!string.equals(&quot;toString()Ljava/lang/String;&quot;)) break; return 4; &#125; case 1984935277: &#123; if (!string.equals(&quot;hashCode()I&quot;)) break; return 5; &#125; &#125; return -1; &#125; @Override public int getMaxIndex() &#123; return 5; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringAop","slug":"SpringAop","permalink":"https://erdong27.github.io/tags/SpringAop/"},{"name":"CGLIB","slug":"CGLIB","permalink":"https://erdong27.github.io/tags/CGLIB/"},{"name":"代理","slug":"代理","permalink":"https://erdong27.github.io/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"github图床搭建","slug":"github图床搭建","date":"2024-07-14T07:51:49.000Z","updated":"2024-07-14T07:51:49.000Z","comments":true,"path":"2024/07/14/github图床搭建/","permalink":"https://erdong27.github.io/2024/07/14/github%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/","excerpt":"","text":"github图床搭建创建仓库 生成令牌 拉到最后点击创建 下载PicGo PicGo下载地址 选择【图床设置】-&gt;【Github】 设置仓库名=用户名+仓库名 设定分支名： 仓库在哪个分支里，就填哪个分支。 设定Token：刚刚创建的token,将其填进去即可。 设置存储路径 统一设置成img/ 设置自定义域名。这个是比较关键的。我们可以用一个免费的加速域名作为我们自定义域名。 设置自定义域名。这个是比较关键的。我们可以用一个免费的加速域名作为我们自定义域名。 那么你所设置的就应当为https://cdn.jsdelivr.net/gh/ +你的账户名+你的仓库名@你的分支名。比如，我上面的就是https://cdn.jsdelivr.net/gh/jianxiangwudi/MyPic@img 按照需要改成你自己的。 需要注意的是，这里一定要设置成@ 设置Typora实现自动上传 点击【文件】-&gt;【偏好设置】-&gt;【图像】 注意 可能会自动上传失败 要自己手动用PicGo上传 Typora下载地址 Typora激活教程 本文参考链接","categories":[{"name":"图床","slug":"图床","permalink":"https://erdong27.github.io/categories/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://erdong27.github.io/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"SpringBoot启动过程","slug":"SpringBoot启动过程","date":"2024-07-13T14:32:21.000Z","updated":"2024-07-13T14:32:21.000Z","comments":true,"path":"2024/07/13/SpringBoot启动过程/","permalink":"https://erdong27.github.io/2024/07/13/SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"SpringBoot启动过程创建 SpringApplication 对象 记录 BeanDefinition 源 推断应用类型 记录 Applicationcontext 初始化器 记录监听器与事件 推断主启动类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.github.ed.test.test7;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.WebApplicationType;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.servlet.server.ServletWebServerFactory;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.support.GenericApplicationContext;import java.lang.reflect.Method;import java.util.Arrays;import java.util.HashSet;public class Test1 &#123; private static final Logger logger = LoggerFactory.getLogger(Test1.class); public static void main(String[] args) throws Exception &#123; // 1.演示获取 BeanDefinition 源 SpringApplication spring=new SpringApplication(Test1.class); spring.setSources(new HashSet&lt;&gt;(Arrays.asList(&quot;classpath:bean2.xml&quot;))); //2.演示推断应用类型 WebApplicationType.deduceFromClasspath() Method declaredMethod = WebApplicationType.class.getDeclaredMethod(&quot;deduceFromClasspath&quot;); declaredMethod.setAccessible(true); System.out.println(&quot;推断应用类型：&quot;+declaredMethod.invoke(null)); //3.演示 Applicationcontext 初始化器 // this.getSpringFactoriesInstances(ApplicationContextInitializer.class) 作用：对Applicationcontext做扩展 spring.addInitializers(applicationContext -&gt; &#123; if(applicationContext instanceof GenericApplicationContext)&#123; GenericApplicationContext genericApplicationContext=(GenericApplicationContext)applicationContext; genericApplicationContext.registerBean(&quot;bean3&quot;,Bean3.class); &#125; System.out.println(&quot;初始化器&quot;); &#125;); //4.演示监听器与事件 //this.getSpringFactoriesInstances(ApplicationListener.class) spring.addListeners(event -&gt; &#123; System.out.println(&quot;\\t事件为：&quot;+event.getClass()); &#125;); //5.推断主启动类 //this.deduceMainApplicationClass(); Method deduceMainApplicationClass = SpringApplication.class.getDeclaredMethod(&quot;deduceMainApplicationClass&quot;); deduceMainApplicationClass.setAccessible(true); System.out.println(&quot;主启动类：&quot;+deduceMainApplicationClass.invoke(spring)); ConfigurableApplicationContext context = spring.run(); for (String beanDefinitionName : context.getBeanDefinitionNames()) &#123; String resourceDescription = context.getBeanFactory().getBeanDefinition(beanDefinitionName).getResourceDescription(); System.out.println(&quot;name:&quot;+beanDefinitionName+&quot;来源：&quot;+resourceDescription); &#125; context.close(); &#125; static class Bean1&#123; public Bean1() &#123; System.out.println(&quot;Bean1&quot;); &#125; &#125; static class Bean2&#123; public Bean2() &#123; System.out.println(&quot;Bean2&quot;); &#125; &#125; static class Bean3&#123; public Bean3() &#123; System.out.println(&quot;Bean3&quot;); &#125; &#125; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; @Bean public ServletWebServerFactory tomcatServletWebServerFactory()&#123; return new TomcatServletWebServerFactory(); &#125;&#125; 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bean2&quot; class=&quot;com.github.ed.test.test7.Test1.Bean2&quot; /&gt;&lt;/beans&gt; 执行 run 方法 得到 SpringApplicationRunListeners, 事件发布器 发布 application starting事件 封装启动 args 准备 Environment 添加命令行参数(*) ConfigurationPropertySources 处理(*) 发布 application environment 已准备事件 通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理(*) application.properties，由StandardConfigDataLocationResolver 解析 spring.application.json 绑定 spring.main 到 SpringApplication 对象(*) 打印banner(*) 创建容器 准备容器 得到所有的BeanDefinition源加载到容器 调用refresh 调用所有实现ApplicationRunner CommandLineRunner 的Bean ==注意：演示基于SpringBoot 2.7.6版本== 演示run执行第1步1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.github.ed.test.test7;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.boot.ConfigurableBootstrapContext;import org.springframework.boot.DefaultBootstrapContext;import org.springframework.boot.SpringApplication;import org.springframework.boot.SpringApplicationRunListener;import org.springframework.boot.context.event.EventPublishingRunListener;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.io.support.SpringFactoriesLoader;import java.lang.reflect.Constructor;import java.time.Duration;import java.util.List;//得到 SpringApplicationRunListeners,事件发布器public class Test2 &#123; public static void main(String[] args) throws Exception &#123; // 1.演示获取 BeanDefinition 源 SpringApplication app=new SpringApplication(Test1.class); app.addListeners(event -&gt; System.out.println(&quot;\\t事件为：&quot;+event.getClass())); //获取事件发送器实现类名 List&lt;String&gt; loadFactoryNames = SpringFactoriesLoader.loadFactoryNames(SpringApplicationRunListener.class, Test2.class.getClassLoader()); for (String loadFactoryName : loadFactoryNames) &#123; System.out.println(loadFactoryName); Class&lt;?&gt; clazz = Class.forName(loadFactoryName); Constructor&lt;?&gt; constructor = clazz.getConstructor(SpringApplication.class, String[].class); SpringApplicationRunListener publisher = (SpringApplicationRunListener) constructor.newInstance(app,args); //发布事件 DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext(); GenericApplicationContext context=new GenericApplicationContext(); publisher.starting(bootstrapContext);//Spring boot 开始启动 publisher.environmentPrepared(bootstrapContext,new StandardEnvironment());// 环境信息准备完毕 publisher.contextPrepared(context);//在Spring容器创建 并调用初始化器之后 发送此事件 publisher.contextLoaded(context);// 在所有的BeanDefinition 加载完毕 context.refresh(); publisher.started(context,Duration.ZERO);//Spring容器初始化完成(refresh 方法调用完毕) publisher.ready(context,Duration.ZERO);// Spring boot 启动完毕 publisher.failed(context,new Exception(&quot;出错了&quot;));//Spring boot 启动报错 &#125; &#125;&#125; 演示8~11步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.github.ed.test.test7;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.boot.SpringApplication;import org.springframework.boot.WebApplicationType;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebApplicationContext;import org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;import org.springframework.boot.web.servlet.server.ServletWebServerFactory;import org.springframework.context.ApplicationContextInitializer;import org.springframework.context.annotation.AnnotatedBeanDefinitionReader;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.io.ClassPathResource;//运行时请添加运行参数--server.port=8080 debugpublic class Test3 &#123; @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) &#123; SpringApplication app=new SpringApplication(); app.addListeners(event -&gt; System.out.println(&quot;执行初始化器增强&quot;)); System.out.println(&quot;======&gt;2.封装启动 args&quot;); System.out.println(&quot;======&gt;8.创建容器&quot;); GenericApplicationContext context = createApplicationContext(WebApplicationType.SERVLET); System.out.println(&quot;======&gt;9.准备容器&quot;); for (ApplicationContextInitializer initializer : app.getInitializers()) &#123; initializer.initialize(context); &#125; System.out.println(&quot;======&gt;10.得到所有的BeanDefinition源加载到容器&quot;); DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory(); AnnotatedBeanDefinitionReader reader1=new AnnotatedBeanDefinitionReader(beanFactory); reader1.register(Config.class); XmlBeanDefinitionReader reader2=new XmlBeanDefinitionReader(beanFactory); reader2.loadBeanDefinitions(new ClassPathResource(&quot;bean4.xml&quot;)); ClassPathBeanDefinitionScanner scanner=new ClassPathBeanDefinitionScanner(beanFactory); scanner.scan(&quot;com.github.ed.test.test7.sub&quot;); System.out.println(&quot;======&gt;11.调用refresh&quot;); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; String resourceDescription = beanFactory.getBeanDefinition(name).getResourceDescription(); System.out.println(&quot;name:&quot;+name+&quot; 来源:&quot;+resourceDescription); &#125; System.out.println(&quot;======&gt;12.执行runner&quot;); &#125; static GenericApplicationContext createApplicationContext(WebApplicationType webApplicationType)&#123; GenericApplicationContext context=null; switch (webApplicationType) &#123; case REACTIVE: context= new AnnotationConfigReactiveWebApplicationContext(); case SERVLET: context= new AnnotationConfigServletWebServerApplicationContext(); break; case NONE: context=new AnnotationConfigApplicationContext(); &#125; return context; &#125; static class Bean4&#123; public Bean4() &#123; &#125; &#125; static class Bean5&#123; public Bean5() &#123; &#125; &#125; static class Bean6&#123; public Bean6() &#123; &#125; &#125; @Configuration static class Config&#123; @Bean public Bean5 bean5()&#123; return new Bean5(); &#125; @Bean public ServletWebServerFactory servletWebServerFactory()&#123; return new TomcatServletWebServerFactory(); &#125; &#125;&#125; 12345678package com.github.ed.test.test7.sub;import org.springframework.stereotype.Component;@Componentpublic class Bean7 &#123;&#125; 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bean4&quot; class=&quot;com.github.ed.test.test7.Test3.Bean4&quot; /&gt;&lt;/beans&gt; 演示第2、12步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.github.ed.test.test7;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.DefaultApplicationArguments;import org.springframework.boot.SpringApplication;import org.springframework.boot.WebApplicationType;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebApplicationContext;import org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;import org.springframework.boot.web.servlet.server.ServletWebServerFactory;import org.springframework.context.ApplicationContextInitializer;import org.springframework.context.annotation.AnnotatedBeanDefinitionReader;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.io.ClassPathResource;import java.util.Arrays;//运行时请添加运行参数--server.port=8080 debugpublic class Test3 &#123; @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) throws Exception &#123; SpringApplication app=new SpringApplication(); app.addListeners(event -&gt; System.out.println(&quot;执行初始化器增强&quot;)); System.out.println(&quot;======&gt;2.封装启动 args&quot;); DefaultApplicationArguments arguments = new DefaultApplicationArguments(args); System.out.println(&quot;======&gt;8.创建容器&quot;); GenericApplicationContext context = createApplicationContext(WebApplicationType.SERVLET); System.out.println(&quot;======&gt;9.准备容器&quot;); for (ApplicationContextInitializer initializer : app.getInitializers()) &#123; initializer.initialize(context); &#125; System.out.println(&quot;======&gt;10.得到所有的BeanDefinition源加载到容器&quot;); DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory(); AnnotatedBeanDefinitionReader reader1=new AnnotatedBeanDefinitionReader(beanFactory); reader1.register(Config.class); XmlBeanDefinitionReader reader2=new XmlBeanDefinitionReader(beanFactory); reader2.loadBeanDefinitions(new ClassPathResource(&quot;bean4.xml&quot;)); ClassPathBeanDefinitionScanner scanner=new ClassPathBeanDefinitionScanner(beanFactory); scanner.scan(&quot;com.github.ed.test.test7.sub&quot;); System.out.println(&quot;======&gt;11.调用refresh&quot;); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; String resourceDescription = beanFactory.getBeanDefinition(name).getResourceDescription(); System.out.println(&quot;name:&quot;+name+&quot; 来源:&quot;+resourceDescription); &#125; System.out.println(&quot;======&gt;12.执行runner&quot;); for (CommandLineRunner commandLineRunner : context.getBeansOfType(CommandLineRunner.class).values()) &#123; commandLineRunner.run(args); &#125; for (ApplicationRunner applicationRunner : context.getBeansOfType(ApplicationRunner.class).values()) &#123; applicationRunner.run(arguments); &#125; &#125; static GenericApplicationContext createApplicationContext(WebApplicationType webApplicationType)&#123; GenericApplicationContext context=null; switch (webApplicationType) &#123; case REACTIVE: context= new AnnotationConfigReactiveWebApplicationContext(); case SERVLET: context= new AnnotationConfigServletWebServerApplicationContext(); break; case NONE: context=new AnnotationConfigApplicationContext(); &#125; return context; &#125; static class Bean4&#123; public Bean4() &#123; &#125; &#125; static class Bean5&#123; public Bean5() &#123; &#125; &#125; static class Bean6&#123; public Bean6() &#123; &#125; &#125; @Configuration static class Config&#123; @Bean public Bean5 bean5()&#123; return new Bean5(); &#125; @Bean public ServletWebServerFactory servletWebServerFactory()&#123; return new TomcatServletWebServerFactory(); &#125; @Bean public ApplicationRunner applicationRunner()&#123; return args -&gt; &#123; System.out.println(&quot;applicationRunner()...&quot;+Arrays.toString(args.getSourceArgs())); System.out.println(args.getOptionNames()); System.out.println(args.getOptionValues(&quot;server.port&quot;)); System.out.println(args.getNonOptionArgs()); &#125;; &#125; @Bean public CommandLineRunner commandLineRunner()&#123; return args -&gt; System.out.println(&quot;commandLineRunner()...&quot;+ Arrays.toString(args)); &#125; &#125;&#125; 演示第3步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.github.ed.test.test7;import org.springframework.boot.DefaultPropertiesPropertySource;import org.springframework.boot.context.properties.source.ConfigurationPropertySources;import org.springframework.core.env.ConfigurablePropertyResolver;import org.springframework.core.env.MutablePropertySources;import org.springframework.core.env.PropertySource;import org.springframework.core.env.SimpleCommandLinePropertySource;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.support.ResourcePropertySource;import java.io.IOException;//准备 Environment 添加命令行参数(*)public class Step3 &#123; public static void main(String[] args) throws IOException &#123; //系统环境变量,properties,yaml ApplicationEnvironment env=new ApplicationEnvironment(); //读取配置文件 env.getPropertySources().addLast(new ResourcePropertySource(new ClassPathResource(&quot;application.properties&quot;))); //设置命令行 env.getPropertySources().addFirst(new SimpleCommandLinePropertySource(args)); for (PropertySource&lt;?&gt; ps : env.getPropertySources()) &#123; System.out.println(ps); &#125; System.out.println(env.getProperty(&quot;JAVA_HOME&quot;)); System.out.println(env.getProperty(&quot;server.port&quot;)); &#125; static class ApplicationEnvironment extends StandardEnvironment&#123; ApplicationEnvironment() &#123; &#125; protected String doGetActiveProfilesProperty() &#123; return null; &#125; protected String doGetDefaultProfilesProperty() &#123; return null; &#125; protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) &#123; return ConfigurationPropertySources.createPropertyResolver(propertySources); &#125; &#125;&#125; 演示第4步123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.github.ed.test.test7;import org.springframework.boot.context.properties.source.ConfigurationPropertySources;import org.springframework.core.env.ConfigurablePropertyResolver;import org.springframework.core.env.MutablePropertySources;import org.springframework.core.env.PropertySource;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.support.ResourcePropertySource;import java.io.IOException;//ConfigurationPropertySources 处理(*)//发布 application environment 已准备事件public class Step4 &#123; public static void main(String [] args)throws IOException, NoSuchFieldException &#123; ApplicationEnvironment env= new ApplicationEnvironment(); env.getPropertySources().addLast(new ResourcePropertySource( &quot;step4&quot;, new ClassPathResource(&quot;step4.properties&quot;))); //添加ConfigurationPropertySourcesPropertySource 解析不规范的符号 ConfigurationPropertySources.attach(env); for (PropertySource&lt;?&gt; propertySource : env.getPropertySources()) &#123; System.out.println(propertySource); &#125; System.out.println(env.getProperty(&quot;user.first-name&quot;)); System.out.println(env.getProperty(&quot;user.middle-name&quot;)); System.out.println(env.getProperty(&quot;user.last-name&quot;));&#125; static class ApplicationEnvironment extends StandardEnvironment &#123; ApplicationEnvironment() &#123; &#125; protected String doGetActiveProfilesProperty() &#123; return null; &#125; protected String doGetDefaultProfilesProperty() &#123; return null; &#125; protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) &#123; return ConfigurationPropertySources.createPropertyResolver(propertySources); &#125; &#125;&#125; 123user.first-name=Georgeceruser.middle_name=Walkenuser.lastName=Bush 演示第5步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.github.ed.test.test7;import org.springframework.boot.DefaultBootstrapContext;import org.springframework.boot.SpringApplication;import org.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor;import org.springframework.boot.context.event.EventPublishingRunListener;import org.springframework.boot.context.properties.source.ConfigurationPropertySources;import org.springframework.boot.env.EnvironmentPostProcessor;import org.springframework.boot.env.EnvironmentPostProcessorApplicationListener;import org.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor;import org.springframework.boot.logging.DeferredLog;import org.springframework.boot.logging.DeferredLogs;import org.springframework.core.env.ConfigurablePropertyResolver;import org.springframework.core.env.MutablePropertySources;import org.springframework.core.env.PropertySource;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.io.support.SpringFactoriesLoader;import java.util.List;/** * 通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理(*) * application.properties，由StandardConfigDataLocationResolver 解析 * spring.application.json */public class Step5 &#123; public static void main(String[] args) &#123; SpringApplication app=new SpringApplication(); app.addListeners(new EnvironmentPostProcessorApplicationListener()); List&lt;String&gt; loadFactoryNames = SpringFactoriesLoader.loadFactoryNames(EnvironmentPostProcessor.class, null); for (String loadFactoryName : loadFactoryNames) &#123; System.out.println(loadFactoryName); &#125; EventPublishingRunListener publisher=new EventPublishingRunListener(app,args); ApplicationEnvironment env=new ApplicationEnvironment(); System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;增强前&quot;); for (PropertySource&lt;?&gt; propertySource : env.getPropertySources()) &#123; System.out.println(propertySource); &#125; publisher.environmentPrepared(new DefaultBootstrapContext(),env); System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;增强后&quot;); for (PropertySource&lt;?&gt; propertySource : env.getPropertySources()) &#123; System.out.println(propertySource); &#125; &#125; private static void test1() &#123; SpringApplication app=new SpringApplication(); ApplicationEnvironment env= new ApplicationEnvironment(); System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;增强前&quot;); for (PropertySource&lt;?&gt; propertySource : env.getPropertySources()) &#123; System.out.println(propertySource); &#125; ConfigDataEnvironmentPostProcessor postProcessor1 = new ConfigDataEnvironmentPostProcessor(new DeferredLogs(), new DefaultBootstrapContext()); postProcessor1.postProcessEnvironment(env, app); System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;增强后&quot;); for (PropertySource&lt;?&gt; propertySource : env.getPropertySources()) &#123; System.out.println(propertySource); &#125; RandomValuePropertySourceEnvironmentPostProcessor postProcessor2=new RandomValuePropertySourceEnvironmentPostProcessor(new DeferredLog()); postProcessor2.postProcessEnvironment(env, app); System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;增强后&quot;); for (PropertySource&lt;?&gt; propertySource : env.getPropertySources()) &#123; System.out.println(propertySource); &#125; System.out.println(env.getProperty(&quot;server.port&quot;)); System.out.println(env.getProperty(&quot;random.int&quot;)); System.out.println(env.getProperty(&quot;random.int&quot;)); System.out.println(env.getProperty(&quot;random.int&quot;)); &#125; static class ApplicationEnvironment extends StandardEnvironment &#123; ApplicationEnvironment() &#123; &#125; protected String doGetActiveProfilesProperty() &#123; return null; &#125; protected String doGetDefaultProfilesProperty() &#123; return null; &#125; protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) &#123; return ConfigurationPropertySources.createPropertyResolver(propertySources); &#125; &#125;&#125; 演示第6步12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.github.ed.test.test7;import org.springframework.boot.SpringApplication;import org.springframework.boot.context.properties.bind.Bindable;import org.springframework.boot.context.properties.bind.Binder;import org.springframework.boot.context.properties.source.ConfigurationPropertySources;import org.springframework.core.env.ConfigurablePropertyResolver;import org.springframework.core.env.MutablePropertySources;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.support.ResourcePropertySource;//绑定 spring.main 到 SpringApplication 对象(*)public class Step6 &#123; public static void main(String[] args) throws Exception&#123; SpringApplication app=new SpringApplication(); ApplicationEnvironment env=new ApplicationEnvironment(); env.getPropertySources().addLast(new ResourcePropertySource( &quot;step4&quot;, new ClassPathResource(&quot;step4.properties&quot;))); env.getPropertySources().addLast(new ResourcePropertySource( &quot;step6&quot;, new ClassPathResource(&quot;step6.properties&quot;))); System.out.println(app); Binder.get(env).bind(&quot;spring.main&quot;, Bindable.ofInstance(app)); System.out.println(app);// User user = Binder.get(env).bind(&quot;user&quot;, User.class).get();// System.out.println(user);// User user1=new User();// Binder.get(env).bind(&quot;user&quot;, Bindable.ofInstance(user1));// System.out.println(user1); &#125; @SuppressWarnings(&quot;all&quot;) static class User &#123; private String firstName; private String middleName; private String lastName; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getMiddleName() &#123; return middleName; &#125; public void setMiddleName(String middleName) &#123; this.middleName = middleName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;firstName=&#x27;&quot; + firstName + &#x27;\\&#x27;&#x27; + &quot;, middleName=&#x27;&quot; + middleName + &#x27;\\&#x27;&#x27; + &quot;, lastName=&#x27;&quot; + lastName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; @SuppressWarnings(&quot;all&quot;) static class ApplicationEnvironment extends StandardEnvironment &#123; ApplicationEnvironment() &#123; &#125; protected String doGetActiveProfilesProperty() &#123; return null; &#125; protected String doGetDefaultProfilesProperty() &#123; return null; &#125; protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) &#123; return ConfigurationPropertySources.createPropertyResolver(propertySources); &#125; &#125;&#125; 12spring.main.banner-mode=offspring.main.lazy-initialization=true 演示第7步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230package com.github.ed.test.test7;import cn.hutool.core.map.MapUtil;import org.apache.commons.logging.Log;import org.springframework.boot.Banner;import org.springframework.boot.ImageBanner;import org.springframework.boot.ResourceBanner;import org.springframework.boot.SpringBootVersion;import org.springframework.boot.ansi.AnsiColor;import org.springframework.boot.ansi.AnsiOutput;import org.springframework.boot.ansi.AnsiStyle;import org.springframework.boot.context.properties.source.ConfigurationPropertySources;import org.springframework.core.env.ConfigurablePropertyResolver;import org.springframework.core.env.Environment;import org.springframework.core.env.MapPropertySource;import org.springframework.core.env.MutablePropertySources;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.io.DefaultResourceLoader;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.util.StringUtils;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.PrintStream;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.Iterator;import java.util.List;//打印banner(*)public class Step7 &#123; public static void main(String[] args) &#123; ApplicationEnvironment env=new ApplicationEnvironment(); SpringApplicationBannerPrinter printer=new SpringApplicationBannerPrinter(new DefaultResourceLoader(),new SpringBootBanner()); //测试文字banner env.getPropertySources().addLast(new MapPropertySource(&quot;custom&quot;, MapUtil.of(&quot;spring.banner.location&quot;,&quot;banner.txt&quot;))); //测试图片banner// env.getPropertySources().addLast(new MapPropertySource(&quot;custom&quot;, MapUtil.of(&quot;spring.banner.image.location&quot;,&quot;banner.png&quot;))); //版本号信息 System.out.println(SpringBootVersion.getVersion()); printer.print(env,Step7.class,System.out); &#125; @SuppressWarnings(&quot;all&quot;) static class ApplicationEnvironment extends StandardEnvironment &#123; ApplicationEnvironment() &#123; &#125; protected String doGetActiveProfilesProperty() &#123; return null; &#125; protected String doGetDefaultProfilesProperty() &#123; return null; &#125; protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) &#123; return ConfigurationPropertySources.createPropertyResolver(propertySources); &#125; &#125;@SuppressWarnings(&quot;all&quot;) static class SpringApplicationBannerPrinter &#123; static final String BANNER_LOCATION_PROPERTY = &quot;spring.banner.location&quot;; static final String BANNER_IMAGE_LOCATION_PROPERTY = &quot;spring.banner.image.location&quot;; static final String DEFAULT_BANNER_LOCATION = &quot;banner.txt&quot;; static final String[] IMAGE_EXTENSION = new String[]&#123;&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;&#125;; private static final Banner DEFAULT_BANNER = new SpringBootBanner(); private final ResourceLoader resourceLoader; private final Banner fallbackBanner; SpringApplicationBannerPrinter(ResourceLoader resourceLoader, Banner fallbackBanner) &#123; this.resourceLoader = resourceLoader; this.fallbackBanner = fallbackBanner; &#125; Banner print(Environment environment, Class&lt;?&gt; sourceClass, Log logger) &#123; Banner banner = this.getBanner(environment); try &#123; logger.info(this.createStringFromBanner(banner, environment, sourceClass)); &#125; catch (UnsupportedEncodingException var6) &#123; logger.warn(&quot;Failed to create String for banner&quot;, var6); &#125; return new SpringApplicationBannerPrinter.PrintedBanner(banner, sourceClass); &#125; Banner print(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123; Banner banner = this.getBanner(environment); banner.printBanner(environment, sourceClass, out); return new SpringApplicationBannerPrinter.PrintedBanner(banner, sourceClass); &#125; private Banner getBanner(Environment environment) &#123; SpringApplicationBannerPrinter.Banners banners = new SpringApplicationBannerPrinter.Banners(); banners.addIfNotNull(this.getImageBanner(environment)); banners.addIfNotNull(this.getTextBanner(environment)); if (banners.hasAtLeastOneBanner()) &#123; return banners; &#125; else &#123; return this.fallbackBanner != null ? this.fallbackBanner : DEFAULT_BANNER; &#125; &#125; private Banner getTextBanner(Environment environment) &#123; String location = environment.getProperty(&quot;spring.banner.location&quot;, &quot;banner.txt&quot;); Resource resource = this.resourceLoader.getResource(location); try &#123; if (resource.exists() &amp;&amp; !resource.getURL().toExternalForm().contains(&quot;liquibase-core&quot;)) &#123; return new ResourceBanner(resource); &#125; &#125; catch (IOException var5) &#123; &#125; return null; &#125; private Banner getImageBanner(Environment environment) &#123; String location = environment.getProperty(&quot;spring.banner.image.location&quot;); if (StringUtils.hasLength(location)) &#123; Resource resource = this.resourceLoader.getResource(location); return resource.exists() ? new ImageBanner(resource) : null; &#125; else &#123; String[] var3 = IMAGE_EXTENSION; int var4 = var3.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; String ext = var3[var5]; Resource resource = this.resourceLoader.getResource(&quot;banner.&quot; + ext); if (resource.exists()) &#123; return new ImageBanner(resource); &#125; &#125; return null; &#125; &#125; private String createStringFromBanner(Banner banner, Environment environment, Class&lt;?&gt; mainApplicationClass) throws UnsupportedEncodingException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); banner.printBanner(environment, mainApplicationClass, new PrintStream(baos)); String charset = environment.getProperty(&quot;spring.banner.charset&quot;, &quot;UTF-8&quot;); return baos.toString(charset); &#125; private static class PrintedBanner implements Banner &#123; private final Banner banner; private final Class&lt;?&gt; sourceClass; PrintedBanner(Banner banner, Class&lt;?&gt; sourceClass) &#123; this.banner = banner; this.sourceClass = sourceClass; &#125; public void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123; sourceClass = sourceClass != null ? sourceClass : this.sourceClass; this.banner.printBanner(environment, sourceClass, out); &#125; &#125; private static class Banners implements Banner &#123; private final List&lt;Banner&gt; banners; private Banners() &#123; this.banners = new ArrayList(); &#125; void addIfNotNull(Banner banner) &#123; if (banner != null) &#123; this.banners.add(banner); &#125; &#125; boolean hasAtLeastOneBanner() &#123; return !this.banners.isEmpty(); &#125; public void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123; Iterator var4 = this.banners.iterator(); while(var4.hasNext()) &#123; Banner banner = (Banner)var4.next(); banner.printBanner(environment, sourceClass, out); &#125; &#125; &#125; &#125; @SuppressWarnings(&quot;all&quot;) static class SpringBootBanner implements Banner &#123; private static final String[] BANNER = new String[]&#123;&quot;&quot;, &quot; . ____ _ __ _ _&quot;, &quot; /\\\\\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\\\ \\\\ \\\\ \\\\&quot;, &quot;( ( )\\\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\\\/ _` | \\\\ \\\\ \\\\ \\\\&quot;, &quot; \\\\\\\\/ ___)| |_)| | | | | || (_| | ) ) ) )&quot;, &quot; &#x27; |____| .__|_| |_|_| |_\\\\__, | / / / /&quot;, &quot; =========|_|==============|___/=/_/_/_/&quot;&#125;; private static final String SPRING_BOOT = &quot; :: Spring Boot :: &quot;; private static final int STRAP_LINE_SIZE = 42; SpringBootBanner() &#123; &#125; public void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream printStream) &#123; String[] var4 = BANNER; int var5 = var4.length; for (int var6 = 0; var6 &lt; var5; ++var6) &#123; String line = var4[var6]; printStream.println(line); &#125; String version = SpringBootVersion.getVersion(); version = version != null ? &quot; (v&quot; + version + &quot;)&quot; : &quot;&quot;; StringBuilder padding = new StringBuilder(); while (padding.length() &lt; 42 - (version.length() + &quot; :: Spring Boot :: &quot;.length())) &#123; padding.append(&quot; &quot;); &#125; printStream.println(AnsiOutput.toString(new Object[]&#123;AnsiColor.GREEN, &quot; :: Spring Boot :: &quot;, AnsiColor.DEFAULT, padding.toString(), AnsiStyle.FAINT, version&#125;)); printStream.println(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"SpringApplication","slug":"SpringApplication","permalink":"https://erdong27.github.io/tags/SpringApplication/"}]},{"title":"事件监听器与发布器","slug":"事件监听器与发布器","date":"2024-07-13T01:32:26.000Z","updated":"2024-07-13T01:32:26.000Z","comments":true,"path":"2024/07/13/事件监听器与发布器/","permalink":"https://erdong27.github.io/2024/07/13/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8E%E5%8F%91%E5%B8%83%E5%99%A8/","excerpt":"","text":"实现ApplicationListener接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.github.ed.test.test6;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationEvent;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationListener;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;@Configurationpublic class Test1 &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(Test1.class); context.getBean(MyService.class).doSome(); context.close(); &#125; @Component static class MyService&#123; private static final Logger logger = LoggerFactory.getLogger(MyService.class); @Autowired private ApplicationEventPublisher publisher; public void doSome()&#123; logger.debug(&quot;主业务&quot;); publisher.publishEvent(new MyEvent(this)); &#125; &#125; static class MyEvent extends ApplicationEvent&#123; public MyEvent(Object source) &#123; super(source); &#125; &#125; @Component static class SmsService implements ApplicationListener&lt;MyEvent&gt;&#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @Override public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送短信&quot;); &#125; &#125; @Component static class EmailService implements ApplicationListener&lt;MyEvent&gt;&#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @Override public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送邮件&quot;); &#125; &#125;&#125; @EventListener注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.github.ed.test.test6;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationEvent;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.event.ApplicationEventMulticaster;import org.springframework.context.event.EventListener;import org.springframework.context.event.SimpleApplicationEventMulticaster;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import org.springframework.stereotype.Component;@Configurationpublic class Test2 &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(Test2.class); context.getBean(MyService.class).doBusiness(); context.close(); &#125; @Component static class MyService&#123; private static final Logger logger = LoggerFactory.getLogger(MyService.class); @Autowired private ApplicationEventPublisher publisher; public void doBusiness()&#123; logger.debug(&quot;主业务&quot;); publisher.publishEvent(new MyEvent(this)); &#125; &#125; static class MyEvent extends ApplicationEvent&#123; public MyEvent(Object source) &#123; super(source); &#125; &#125; @Component static class SmsService &#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @EventListener public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送短信&quot;); &#125; &#125; @Component static class EmailService &#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @EventListener public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送邮件&quot;); &#125; &#125; @Bean public ThreadPoolTaskExecutor threadPoolTaskExecutor()&#123; ThreadPoolTaskExecutor executor=new ThreadPoolTaskExecutor(); executor.setCorePoolSize(3); executor.setMaxPoolSize(10); executor.setQueueCapacity(100); return executor; &#125; // 添加线程异步处理 @Bean public ApplicationEventMulticaster applicationEventMulticaster(ThreadPoolTaskExecutor threadPoolTaskExecutor)&#123; SimpleApplicationEventMulticaster multicaster=new SimpleApplicationEventMulticaster(); multicaster.setTaskExecutor(threadPoolTaskExecutor); return multicaster; &#125;&#125; 自定义注解解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.github.ed.test.test6;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.SmartInitializingSingleton;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationEvent;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationListener;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 自定义监听器注解类 */@Configurationpublic class Test3 &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(Test3.class); context.getBean(MyService.class).doBusiness(); for (String beanDefinitionName : context.getBeanDefinitionNames()) &#123; System.out.println(beanDefinitionName); &#125; context.close(); &#125; @Component static class MyService&#123; private static final Logger logger = LoggerFactory.getLogger(MyService.class); @Autowired private ApplicationEventPublisher publisher; public void doBusiness()&#123; logger.debug(&quot;主业务&quot;); publisher.publishEvent(new MyEvent(this)); &#125; &#125; static class MyEvent extends ApplicationEvent&#123; public MyEvent(Object source) &#123; super(source); &#125; &#125; @Component static class SmsService &#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @SuppressWarnings(&quot;all&quot;) @MyListener public void onApplicationEvent(MyEvent event)&#123; logger.debug(&quot;发送短信&quot;); &#125; &#125; @Component static class EmailService &#123; private static final Logger logger = LoggerFactory.getLogger(EmailService.class); @SuppressWarnings(&quot;all&quot;) @MyListener public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送邮件&quot;); &#125; @Bean @SuppressWarnings(&quot;all&quot;) public SmartInitializingSingleton smartInitializingSingleton(ConfigurableApplicationContext context)&#123; return () -&gt; &#123; for (String beanDefinitionName : context.getBeanDefinitionNames()) &#123; Object bean = context.getBean(beanDefinitionName); for (Method method : bean.getClass().getMethods()) &#123; if(method.isAnnotationPresent(MyListener.class))&#123; ApplicationListener applicationListener = event -&gt; &#123; try &#123; //监听器需要的事件类型 Class&lt;?&gt; eventType = method.getParameterTypes()[0]; if (eventType.isAssignableFrom(event.getClass())) &#123; method.invoke(bean, event); &#125; &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; throw new RuntimeException(e); &#125; &#125;; context.addApplicationListener(applicationListener); &#125; &#125; &#125; &#125;; &#125; &#125; @Documented @Target(&#123;ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface MyListener &#123; &#125;&#125; ApplicationEventMulticaster123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.github.ed.test.test6;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationEvent;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationListener;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.event.ApplicationEventMulticaster;import org.springframework.context.event.GenericApplicationListener;import org.springframework.core.ResolvableType;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;@Configurationpublic class Test4 &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(Test4.class); context.getBean(MyService.class).doBusiness(); context.close(); &#125; @Component static class MyService&#123; private static final Logger logger = LoggerFactory.getLogger(MyService.class); @Autowired private ApplicationEventPublisher publisher; public void doBusiness()&#123; logger.debug(&quot;主业务&quot;); publisher.publishEvent(new MyEvent(this)); &#125; &#125; static class MyEvent extends ApplicationEvent&#123; public MyEvent(Object source) &#123; super(source); &#125; &#125; @Component static class SmsService implements ApplicationListener&lt;MyEvent&gt;&#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @SuppressWarnings(&quot;all&quot;) @Override public void onApplicationEvent(MyEvent event)&#123; logger.debug(&quot;发送短信&quot;); &#125; &#125; @Component static class EmailService implements ApplicationListener&lt;MyEvent&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(EmailService.class); @SuppressWarnings(&quot;all&quot;) @Override public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送邮件&quot;); &#125; @Bean @SuppressWarnings(&quot;all&quot;) public ApplicationEventMulticaster applicationEventMulticaster(ConfigurableApplicationContext context) &#123; return new AbstractApplicationEventMulticaster() &#123; private List&lt;GenericApplicationListener&gt; listeners = new ArrayList&lt;&gt;(); @Override public void addApplicationListenerBean(String name) &#123; ApplicationListener listener = context.getBean(name, ApplicationListener.class); //获取该监听器支持的事件类型 ResolvableType type = ResolvableType.forClass(listener.getClass()).getInterfaces()[0].getGeneric(); //将原始的listener封装为支持事件类型检查的listener GenericApplicationListener genericApplicationListener = new GenericApplicationListener() &#123; //是否支持某个事件类型 @Override public boolean supportsEventType(ResolvableType eventType) &#123; return type.isAssignableFrom(eventType); &#125; @Override public void onApplicationEvent(ApplicationEvent event) &#123; listener.onApplicationEvent(event); &#125; &#125;; listeners.add(genericApplicationListener); &#125; @Override public void multicastEvent(ApplicationEvent event, ResolvableType eventType) &#123; for (GenericApplicationListener listener : listeners) &#123; if (listener.supportsEventType(ResolvableType.forClass(event.getClass()))) &#123; listener.onApplicationEvent(event); &#125; &#125; &#125; &#125;; &#125; static class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster &#123; @Override public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123; &#125; @Override public void addApplicationListenerBean(String listenerBeanName) &#123; &#125; @Override public void removeApplicationListener(ApplicationListener&lt;?&gt; listener) &#123; &#125; @Override public void removeApplicationListenerBean(String listenerBeanName) &#123; &#125; @Override public void removeApplicationListeners(Predicate&lt;ApplicationListener&lt;?&gt;&gt; predicate) &#123; &#125; @Override public void removeApplicationListenerBeans(Predicate&lt;String&gt; predicate) &#123; &#125; @Override public void removeAllListeners() &#123; &#125; @Override public void multicastEvent(ApplicationEvent event) &#123; &#125; @Override public void multicastEvent(ApplicationEvent event, ResolvableType eventType) &#123; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164package com.github.ed.test.test6;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.aop.framework.AopProxyUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationEvent;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationListener;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.event.ApplicationEventMulticaster;import org.springframework.context.event.EventListener;import org.springframework.context.event.GenericApplicationListener;import org.springframework.core.ResolvableType;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;@Configurationpublic class Test5 &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(Test5.class); context.getBean(MyService.class).doBusiness(); context.close(); &#125; @Component static class MyService&#123; private static final Logger logger = LoggerFactory.getLogger(MyService.class); @Autowired private ApplicationEventPublisher publisher; public void doBusiness()&#123; logger.debug(&quot;主业务&quot;); publisher.publishEvent(new MyEvent(this)); &#125; &#125; static class MyEvent extends ApplicationEvent &#123; public MyEvent(Object source) &#123; super(source); &#125; &#125; @Component static class SmsService &#123; private static final Logger logger = LoggerFactory.getLogger(SmsService.class); @SuppressWarnings(&quot;all&quot;) @EventListener public void onApplicationEvent(MyEvent event)&#123; logger.debug(&quot;发送短信&quot;); &#125; &#125; @Component static class EmailService &#123; private static final Logger logger = LoggerFactory.getLogger(EmailService.class); @SuppressWarnings(&quot;all&quot;) @EventListener public void onApplicationEvent(MyEvent event) &#123; logger.debug(&quot;发送邮件&quot;); &#125; @Bean @SuppressWarnings(&quot;all&quot;) public ApplicationEventMulticaster applicationEventMulticaster(ConfigurableApplicationContext context) &#123; return new EmailService.AbstractApplicationEventMulticaster() &#123; private List&lt;GenericApplicationListener&gt; listeners = new ArrayList&lt;&gt;(); @Override public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123; listeners.add((GenericApplicationListener) listener); &#125; @Override public void addApplicationListenerBean(String name) &#123; ApplicationListener listener = context.getBean(name, ApplicationListener.class); //获取该监听器支持的事件类型 ResolvableType type = ResolvableType.forClass(listener.getClass()).getInterfaces()[0].getGeneric(); //将原始的listener封装为支持事件类型检查的listener GenericApplicationListener genericApplicationListener = new GenericApplicationListener() &#123; //是否支持某个事件类型 @Override public boolean supportsEventType(ResolvableType eventType) &#123; return type.isAssignableFrom(eventType); &#125; @Override public void onApplicationEvent(ApplicationEvent event) &#123; listener.onApplicationEvent(event); &#125; &#125;; listeners.add(genericApplicationListener); &#125; @Override public void multicastEvent(ApplicationEvent event, ResolvableType eventType) &#123; for (GenericApplicationListener listener : listeners) &#123; if (listener.supportsEventType(ResolvableType.forClass(event.getClass()))) &#123; listener.onApplicationEvent(event); &#125; &#125; &#125; &#125;; &#125; static class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster &#123; @Override public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123; &#125; @Override public void addApplicationListenerBean(String listenerBeanName) &#123; &#125; @Override public void removeApplicationListener(ApplicationListener&lt;?&gt; listener) &#123; &#125; @Override public void removeApplicationListenerBean(String listenerBeanName) &#123; &#125; @Override public void removeApplicationListeners(Predicate&lt;ApplicationListener&lt;?&gt;&gt; predicate) &#123; &#125; @Override public void removeApplicationListenerBeans(Predicate&lt;String&gt; predicate) &#123; &#125; @Override public void removeAllListeners() &#123; &#125; @Override public void multicastEvent(ApplicationEvent event) &#123; &#125; @Override public void multicastEvent(ApplicationEvent event, ResolvableType eventType) &#123; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"ApplicationListener","slug":"ApplicationListener","permalink":"https://erdong27.github.io/tags/ApplicationListener/"},{"name":"EventListener","slug":"EventListener","permalink":"https://erdong27.github.io/tags/EventListener/"}]},{"title":"SpringBoot自动配置","slug":"SpringBoot自动配置","date":"2024-07-12T14:41:21.000Z","updated":"2024-07-12T14:41:21.000Z","comments":true,"path":"2024/07/12/SpringBoot自动配置/","permalink":"https://erdong27.github.io/2024/07/12/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/","excerpt":"","text":"通过@Import&amp;@Configuration12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.github.ed.test.test5;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ConfigurationClassPostProcessor;import org.springframework.context.annotation.Import;import org.springframework.context.support.GenericApplicationContext;public class Test &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; context.close(); &#125; @Configuration @Import(&#123;Config1.class,Config2.class&#125;) static class Config&#123; &#125; @Configuration public static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; &#125; @Configuration public static class Config2&#123; @Bean public Bean2 bean1()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; &#125;&#125; 自己实现ImportSelector接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.github.ed.test.test5;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ConfigurationClassPostProcessor;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.ImportSelector;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.type.AnnotationMetadata;public class Test &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; context.close(); &#125; @Configuration @Import(&#123;MyImportSelector.class&#125;) static class Config&#123; &#125; static class MyImportSelector implements ImportSelector &#123; @Override @SuppressWarnings(&quot;all&quot;) public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;Bean1.class.getName(),Bean2.class.getName()&#125;; &#125; &#125; @Configuration public static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; &#125; @Configuration public static class Config2&#123; @Bean public Bean2 bean1()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; &#125;&#125; 通过配置文件spring.factories123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.github.ed.test.test5;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ConfigurationClassPostProcessor;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.ImportSelector;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.io.support.SpringFactoriesLoader;import org.springframework.core.type.AnnotationMetadata;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); //设置BeanDefinition不能重写 context.setAllowBeanDefinitionOverriding(false); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; System.out.println(context.getBean(Bean1.class)); context.close(); &#125; @Configuration //本项目配置类 @Import(MyImportSelector.class) public static class Config&#123; @Bean @ConditionalOnMissingBean public Bean1 bean1()&#123; return new Bean1(&quot;本项目&quot;); &#125; &#125; /** * DeferredImportSelector 可以让本项目的优先级大于第三方的 */ static class MyImportSelector implements ImportSelector &#123; @Override @SuppressWarnings(&quot;all&quot;) public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; List&lt;String&gt; loadFactoryNames = SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, null); System.out.println(&quot;==============&gt;&quot;); for (String name : loadFactoryNames) &#123; System.out.println(name); &#125; List&lt;String&gt; factoryNames = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null); return factoryNames.toArray(new String[0]); &#125; &#125; @Configuration static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(&quot;第三方&quot;); &#125; &#125; @Configuration public static class Config2&#123; @Bean public Bean2 bean2()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; @Override public String toString() &#123; return &quot;Bean1&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; @Override public String toString() &#123; return &quot;Bean2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125;&#125; 1234567891011# Auto Configure# 内部类用$com.github.ed.test.test5.Test$MyImportSelector=\\com.github.ed.test.test5.Test$Config1,\\com.github.ed.test.test5.Test$Config2org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.github.ed.test.test5.TestAopAutoConfiguration$Config1,\\com.github.ed.test.test5.TestAopAutoConfiguration$Config2 路径为resources下的META-INF/spring.factoriespublic static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 如果本项目beanName与第三方beanName相同 默认是第三方的优先级高 实现DeferredImportSelector接口让本项目优先级高 @ConditionalOnMissingBean如果没有相同名字的bean那么使用当前这个bean 有就不用 自定义条件装配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.github.ed.test.test5;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.AnnotationConfigUtils;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.env.SimpleCommandLinePropertySource;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.type.AnnotatedTypeMetadata;import org.springframework.util.ClassUtils;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.Map;public class TestAopAutoConfiguration &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); StandardEnvironment env=new StandardEnvironment(); env.getPropertySources().addLast(new SimpleCommandLinePropertySource( &quot;--spring.aop.auto=true&quot;, &quot;--spring.datasource.url=jdbc:mysql://localhost:3306/spikes&quot;, &quot;--spring.datasource.username=root&quot;, &quot;--spring.datasource.password=&quot; )); context.setEnvironment(env); AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory()); context.registerBean(Config.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; String description = context.getBeanDefinition(name).getResourceDescription(); if(description!=null) System.out.println(name+&quot;来源：&quot;+description); &#125; context.close(); &#125; @Configuration @EnableAutoConfiguration public static class Config&#123; &#125; @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @Conditional(MyConditional1.class) @interface ConditionalOnClass&#123; boolean exists() ; String className(); &#125; @SuppressWarnings(&quot;all&quot;) static class MyConditional1 implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Map&lt;String, Object&gt; annotationAttributes = metadata.getAnnotationAttributes(ConditionalOnClass.class.getName()); String className = (String)annotationAttributes .get(&quot;className&quot;); boolean exists = (boolean) annotationAttributes.get(&quot;exists&quot;); boolean present = ClassUtils.isPresent(className, null); return exists == present; &#125; &#125; @Configuration @ConditionalOnClass(exists = false,className = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;) static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; &#125; @Configuration @ConditionalOnClass(exists = true,className = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;) static class Config2&#123; @Bean public Bean2 bean2()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; @Override public String toString() &#123; return &quot;Bean1&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; @Override public String toString() &#123; return &quot;Bean2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Srping","slug":"Srping","permalink":"https://erdong27.github.io/tags/Srping/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"EnableAutoConfiguration","slug":"EnableAutoConfiguration","permalink":"https://erdong27.github.io/tags/EnableAutoConfiguration/"}]},{"title":"Tomcat内嵌容器","slug":"Tomcat内嵌容器","date":"2024-07-12T03:27:32.000Z","updated":"2024-07-12T03:27:32.000Z","comments":true,"path":"2024/07/12/Tomcat内嵌容器/","permalink":"https://erdong27.github.io/2024/07/12/Tomcat%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8/","excerpt":"","text":"Tomcat结构图 Tomcat内嵌容器 创建 Tomcat 对象 创建项目文件来，即docBase文件夹 创建Tomcat 项目，在Tomcat 中称为 Context 编程添加 Servlet 启动 Tomcat 创建连接器,设置监听端口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.github.ed.test.test3.test4;import org.apache.catalina.Context;import org.apache.catalina.connector.Connector;import org.apache.catalina.servlets.DefaultServlet;import org.apache.catalina.startup.Tomcat;import org.apache.coyote.http11.Http11Nio2Protocol;import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import javax.servlet.ServletContainerInitializer;import javax.servlet.ServletContext;import javax.servlet.ServletException;import java.io.File;import java.nio.file.Files;import java.util.Collections;import java.util.Set;public class TestTomcat &#123; @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) throws Exception &#123;// 1.创建 Tomcat 对象 Tomcat tomcat=new Tomcat(); tomcat.setBaseDir(&quot;tomcat&quot;);// 2.创建项目文件来，即docBase文件夹 File docBase = Files.createTempDirectory(&quot;boot.&quot;).toFile(); docBase.deleteOnExit();// 3.创建Tomcat 项目，在Tomcat 中称为 Context Context context = tomcat.addContext(&quot;&quot;, docBase.getAbsolutePath()); WebApplicationContext springContext = getApplicationContext();// 4.编程添加 Servlet context.addServletContainerInitializer(new ServletContainerInitializer() &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; cs, ServletContext ctx) throws ServletException &#123; ctx.addServlet(&quot;aaa&quot;,new DefaultServlet()).addMapping(&quot;/hello&quot;);// DispatcherServlet dispatcherServlet = springContext.getBean(DispatcherServlet.class);// ctx.addServlet(&quot;dispatcherServlet&quot;,dispatcherServlet).addMapping(&quot;/&quot;); for (ServletRegistrationBean registrationBean :springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123; registrationBean.onStartup(ctx); &#125; &#125; &#125;, Collections.emptySet());// 5.启动 Tomcat tomcat.start();// 6.创建连接器,设置监听端口 Connector connector = new Connector(new Http11Nio2Protocol()); connector.setPort(8080); tomcat.setConnector(connector); &#125; public static WebApplicationContext getApplicationContext()&#123; AnnotationConfigWebApplicationContext context=new AnnotationConfigWebApplicationContext(); context.register(Config.class); context.refresh(); return context; &#125; @Configuration static class Config &#123; @Bean public DispatcherServlet dispatcherServlet()&#123; return new DispatcherServlet(); &#125; @Bean public DispatcherServletRegistrationBean dispatcherServletRegistrationBean(DispatcherServlet dispatcherServlet)&#123; return new DispatcherServletRegistrationBean(dispatcherServlet,&quot;/&quot;) ; &#125; @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setMessageConverters(Collections.singletonList(new MappingJackson2HttpMessageConverter())); return adapter; &#125; @Controller static class Controller1 &#123; @GetMapping(&quot;/hello2&quot;) @ResponseBody public String hello()&#123; return &quot;hello2&quot;; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://erdong27.github.io/tags/Tomcat/"}]},{"title":"tomcat异常处理","slug":"tomcat异常处理","date":"2024-07-11T15:52:44.000Z","updated":"2024-07-11T15:52:44.000Z","comments":true,"path":"2024/07/11/tomcat异常处理/","permalink":"https://erdong27.github.io/2024/07/11/tomcat%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"自定义error控制器123456789101112131415161718package com.github.ed.test.test3;import org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;public class Test &#123; public static void main(String[] args) &#123; AnnotationConfigServletWebServerApplicationContext context=new AnnotationConfigServletWebServerApplicationContext(WebConfig.class); RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); requestMappingHandlerMapping.getHandlerMethods().forEach( (k,v)-&gt;&#123; System.out.println(&quot;映射路径：&quot;+k+&quot;，方法信息：&quot;+v); &#125; ); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.github.ed.test.test3;import org.springframework.boot.autoconfigure.web.ErrorProperties;import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;import org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController;import org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.ErrorPage;import org.springframework.boot.web.server.ErrorPageRegistrar;import org.springframework.boot.web.server.ErrorPageRegistrarBeanPostProcessor;import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.view.BeanNameViewResolver;import javax.servlet.RequestDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Collections;import java.util.HashMap;import java.util.Map;@Configurationpublic class WebConfig &#123; //tomcat容器创建 @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory()&#123; TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory(); return tomcatServletWebServerFactory; &#125;//DispatcherServlet创建 @Bean public DispatcherServlet dispatcherServlet()&#123; return new DispatcherServlet(); &#125;//将DispatcherServlet注册到tomcat容器中 @Bean public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet)&#123; return new DispatcherServletRegistrationBean(dispatcherServlet, &quot;/&quot;); &#125; @Bean public RequestMappingHandlerMapping requestMappingHandlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125; //默认RequestMappingHandlerAdapter没有Jackson转换器 @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setMessageConverters(Collections.singletonList(new MappingJackson2HttpMessageConverter())); return adapter; &#125; //修改Tomcat服务器默认错误页面地址 @Bean public ErrorPageRegistrar errorPageRegistrar()&#123; return registry -&gt; registry.addErrorPages(new ErrorPage(&quot;/error&quot;)); &#125; //错误注册中心后置处理器 @Bean public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor()&#123; return new ErrorPageRegistrarBeanPostProcessor(); &#125; @Controller static class Controller1&#123; @RequestMapping(&quot;/test&quot;) public ModelAndView test()&#123; int i=1/0; return null; &#125; @RequestMapping(&quot;/error&quot;) @ResponseBody public Map&lt;String,Object&gt; error(HttpServletRequest request)&#123; Throwable e = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;error&quot;, e.getMessage()); return map; &#125; &#125;&#125; BasicErrorController方式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.github.ed.test.test3;import org.springframework.boot.autoconfigure.web.ErrorProperties;import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;import org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController;import org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.ErrorPage;import org.springframework.boot.web.server.ErrorPageRegistrar;import org.springframework.boot.web.server.ErrorPageRegistrarBeanPostProcessor;import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.view.BeanNameViewResolver;import javax.servlet.RequestDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Collections;import java.util.HashMap;import java.util.Map;@Configurationpublic class WebConfig &#123; @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory()&#123; TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory(); return tomcatServletWebServerFactory; &#125; @Bean public DispatcherServlet dispatcherServlet()&#123; return new DispatcherServlet(); &#125; @Bean public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet)&#123; return new DispatcherServletRegistrationBean(dispatcherServlet, &quot;/&quot;); &#125; @Bean public RequestMappingHandlerMapping requestMappingHandlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125;//默认RequestMappingHandlerAdapter没有Jackson转换器 @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setMessageConverters(Collections.singletonList(new MappingJackson2HttpMessageConverter())); return adapter; &#125; //修改Tomcat服务器默认错误页面地址 @Bean public ErrorPageRegistrar errorPageRegistrar()&#123; return registry -&gt; registry.addErrorPages(new ErrorPage(&quot;/error&quot;)); &#125; //错误注册中心后置处理器 @Bean public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor()&#123; return new ErrorPageRegistrarBeanPostProcessor(); &#125; @Bean public BasicErrorController basicErrorController()&#123; ErrorProperties errorProperties = new ErrorProperties(); errorProperties.setIncludeException(true); return new BasicErrorController(new DefaultErrorAttributes(), errorProperties); &#125; @Bean public View error()&#123; return new View() &#123; @Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(&quot;&lt;h3&gt;服务器内部错误&lt;/h3&gt;&quot;); &#125; &#125;; &#125; @Bean public ViewResolver viewResolver()&#123; return new BeanNameViewResolver(); &#125; @Controller static class Controller1&#123; @RequestMapping(&quot;/test&quot;) public ModelAndView test()&#123; int i=1/0; return null; &#125; &#125;&#125; 在浏览器访问时 响应头为content-type:text/html不能正确处理 要自定义视图View 响应头中content-type:application/json格式的可以正常访问","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://erdong27.github.io/tags/SpringMVC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://erdong27.github.io/tags/Tomcat/"}]},{"title":"对象绑定与类型转换","slug":"对象绑定与类型转换","date":"2024-07-10T12:34:57.000Z","updated":"2024-07-10T12:34:57.000Z","comments":true,"path":"2024/07/10/对象绑定与类型转换/","permalink":"https://erdong27.github.io/2024/07/10/%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"底层第一套转换接口 底层第二套转换接口 高层接口与实现 演示SimpleTypeConverter1234567891011121314151617package com.github.ed.test.test1;import org.springframework.beans.SimpleTypeConverter;import java.util.Date;public class TestSimpleTypeConverter &#123; public static void main(String[] args) &#123; SimpleTypeConverter simpleTypeConverter=new org.springframework.beans.SimpleTypeConverter(); Integer number = simpleTypeConverter.convertIfNecessary(&quot;13&quot;, int.class); Date date = simpleTypeConverter.convertIfNecessary(&quot;1997/03/21&quot;, Date.class); System.out.println(number); System.out.println(date); &#125;&#125; DirectFieldAccessor1234567891011121314151617181920212223242526272829303132333435363738package com.github.ed.test.test1;import org.springframework.beans.DirectFieldAccessor;import java.util.Date;/** * 走成员变量赋值 */public class TestFieldWrapper &#123; public static void main(String[] args) &#123; TestBeanWrapper.MyBean target = new TestBeanWrapper.MyBean(); DirectFieldAccessor directFieldAccessor=new DirectFieldAccessor(target); directFieldAccessor.setPropertyValue(&quot;a&quot;,&quot;10&quot;); directFieldAccessor.setPropertyValue(&quot;b&quot;,&quot;hello&quot;); directFieldAccessor.setPropertyValue(&quot;c&quot;,&quot;1997/03/21&quot;); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; BeanWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.github.ed.test.test1;import org.springframework.beans.BeanWrapper;import org.springframework.beans.BeanWrapperImpl;import java.util.Date;/** * 走反射set方法赋值 */public class TestBeanWrapper &#123; public static void main(String[] args) &#123; MyBean target = new MyBean(); BeanWrapper beanWrapper=new BeanWrapperImpl(target); beanWrapper.setPropertyValue(&quot;a&quot;,&quot;10&quot;); beanWrapper.setPropertyValue(&quot;b&quot;,&quot;hello&quot;); beanWrapper.setPropertyValue(&quot;c&quot;,&quot;1997/03/21&quot;); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Date getC() &#123; return c; &#125; public void setC(Date c) &#123; this.c = c; &#125; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; DataBinder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.github.ed.test.test1;import org.springframework.beans.MutablePropertyValues;import org.springframework.validation.DataBinder;import java.util.Date;/** * 有两种方式 * 1.走反射set方法 * 2. dataBinder.initDirectFieldAccess(); */public class TestDateBinder &#123; public static void main(String[] args) &#123; MyBean target = new MyBean(); DataBinder dataBinder=new DataBinder(target); dataBinder.initDirectFieldAccess(); MutablePropertyValues pvs=new MutablePropertyValues(); pvs.add(&quot;a&quot;,&quot;10&quot;); pvs.add(&quot;b&quot;,&quot;hello&quot;); pvs.add(&quot;c&quot;,&quot;1997/03/21&quot;); dataBinder.bind(pvs); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Date getC() &#123; return c; &#125; public void setC(Date c) &#123; this.c = c; &#125; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; Web环境下数据绑定ServletRequestDataBinder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.github.ed.test.test1;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.web.bind.ServletRequestDataBinder;import org.springframework.web.bind.ServletRequestParameterPropertyValues;import java.util.Date;public class TestServletRequestDataBinder &#123; public static void main(String[] args) &#123; //web环境下数据绑定 MyBean target = new MyBean(); ServletRequestDataBinder dataBinder=new ServletRequestDataBinder(target); MockHttpServletRequest request=new MockHttpServletRequest(); request.setParameter(&quot;a&quot;,&quot;10&quot;); request.setParameter(&quot;b&quot;,&quot;hello&quot;); request.setParameter(&quot;c&quot;,&quot;1997/03/21&quot;); dataBinder.bind(new ServletRequestParameterPropertyValues(request)); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Date getC() &#123; return c; &#125; public void setC(Date c) &#123; this.c = c; &#125; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; 参考链接","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://erdong27.github.io/tags/SpringMVC/"},{"name":"SpringWeb","slug":"SpringWeb","permalink":"https://erdong27.github.io/tags/SpringWeb/"}]},{"title":"获取方法参数名","slug":"获取参数名","date":"2024-07-10T12:19:39.000Z","updated":"2024-07-10T12:19:39.000Z","comments":true,"path":"2024/07/10/获取参数名/","permalink":"https://erdong27.github.io/2024/07/10/%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%90%8D/","excerpt":"","text":"12#编译成class文件javac xxx.java 12# class里面有加本地变量表 asm使用 被编译的是接口方法无效javac -g xxx.java 12# class里面有加方法参数 jdk反射使用使用javac -parameters xxx.java 12# 反编译查看javap -c -v xxx.java 测试javac -parameters1234567891011121314151617181920package com.github.ed.test.test2;import java.lang.reflect.Method;import java.lang.reflect.Parameter;public class Bean1 &#123; public void foo(String name,String value)&#123; &#125; public static void main(String[] args) throws Exception &#123; Method method = Bean1.class.getMethod(&quot;foo&quot;, String.class,String.class); for (Parameter parameter : method.getParameters()) &#123; System.out.println(parameter.getName()); &#125; &#125;&#125; javac -g123456789101112131415package com.github.ed.test.test2;import org.springframework.core.LocalVariableTableParameterNameDiscoverer;public class A22 &#123; public static void main(String[] args) &#123; LocalVariableTableParameterNameDiscoverer localVariableTableParameterNameDiscoverer=new LocalVariableTableParameterNameDiscoverer(); String[] names = localVariableTableParameterNameDiscoverer.getParameterNames(Bean1.class.getMethod(&quot;foo&quot;, String.class, String.class)); for (String name : names) &#123; System.out.println(name); &#125; &#125;&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"https://erdong27.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"}]},{"title":"BeanFactory容器的实现","slug":"BeanFactory容器实现","date":"2024-07-10T08:41:34.000Z","updated":"2024-07-10T08:41:34.000Z","comments":true,"path":"2024/07/10/BeanFactory容器实现/","permalink":"https://erdong27.github.io/2024/07/10/BeanFactory%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 @Configuration static class Config&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; @Bean public Bean2 bean2()&#123; return new Bean2(); &#125; @Bean public Bean3 bean3()&#123; return new Bean3(); &#125; @Bean public Bean4 bean4()&#123; return new Bean4(); &#125; interface Inter &#123; &#125; static class Bean1&#123; public Bean1() &#123; System.out.println(&quot;Bean1构造器&quot;); &#125; @Autowired private Bean2 bean2; @Autowired @Resource(name = &quot;bean4&quot;) private Inter bean3; public Bean2 getBean2() &#123; return bean2; &#125; public Inter getInter()&#123; return bean3; &#125; &#125; static class Bean2&#123; public Bean2() &#123; System.out.println(&quot;Bean2构造器&quot;); &#125; &#125; static class Bean3 implements Inter&#123; public Bean3() &#123; System.out.println(&quot;Bean3构造器&quot;); &#125; &#125; static class Bean4 implements Inter&#123; public Bean4() &#123; System.out.println(&quot;Bean4构造器&quot;); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; &#125; 添加beanFactory后置处理器1234567891011121314151617public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); //添加常用的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //BeanFactory 后置处理器主要功能 补充一些bean定义 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach( beanFactoryPostProcessor-&gt;&#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); &#125;); for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; System.out.println(beanFactory.getBean(Config.Bean1.class).getBean2());&#125; 添加bean后置处理器1234567891011121314151617181920212223public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); //添加常用的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //BeanFactory 后置处理器主要功能 补充一些bean定义 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach( beanFactoryPostProcessor-&gt;&#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); &#125;); //Bean后处理器 针对bean的生命周期的各个阶段提供扩展 例如@Autowired @Resource for (BeanPostProcessor beanPostProcessor : beanFactory.getBeansOfType(BeanPostProcessor.class).values()) &#123; beanFactory.addBeanPostProcessor(beanPostProcessor); &#125; for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; beanFactory.preInstantiateSingletons();//准备好所有单例 System.out.println(&quot;==============&gt;&quot;); System.out.println(beanFactory.getBean(Config.Bean1.class).getBean2());&#125; 总结beanFactory不会做的事 不会主动调用BeanFactory后置处理器 不会主动添加bean后置处理器 不会主动初始化单例 不会解析beanFactory 不会解析${} #{} bean后置处理器会有排序的逻辑先加载的后置处理器优先级高1234567891011121314151617181920212223242526public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); //添加常用的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //BeanFactory 后置处理器主要功能 补充一些bean定义 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach( beanFactoryPostProcessor-&gt;&#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); &#125;); //Bean后处理器 针对bean的生命周期的各个阶段提供扩展 例如@Autowired @Resource beanFactory.getBeansOfType(BeanPostProcessor.class) .values().stream().sorted(beanFactory.getDependencyComparator()).forEach(beanPostProcessor -&gt; &#123; System.out.println(&quot;===&gt;&quot;+beanPostProcessor); beanFactory.addBeanPostProcessor(beanPostProcessor); &#125;); for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; beanFactory.preInstantiateSingletons();//准备好所有单例 System.out.println(&quot;==============&gt;&quot;); System.out.println(beanFactory.getBean(Config.Bean1.class).getInter());&#125;","categories":[{"name":"BeanFactory","slug":"BeanFactory","permalink":"https://erdong27.github.io/categories/BeanFactory/"},{"name":"ApplicaionContext","slug":"BeanFactory/ApplicaionContext","permalink":"https://erdong27.github.io/categories/BeanFactory/ApplicaionContext/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"}]},{"title":"ConfigurableApplicaionContext","slug":"容器接口ApplicationContext","date":"2024-07-10T08:34:50.000Z","updated":"2024-07-10T08:34:50.000Z","comments":true,"path":"2024/07/10/容器接口ApplicationContext/","permalink":"https://erdong27.github.io/2024/07/10/%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3ApplicationContext/","excerpt":"","text":"ConfigurableApplicaionContext类图 国际化1context.getMessage(&quot;hi&quot;,null, Locale.CANADA); 根据通配符获取资源1context.getResources(&quot;classpath*:top/javahai/subtlechat/test/**/*.class&quot;); “classpath*”中的 星号表示jar包中的也会扫描到 获取配置信息环境变量12context.getEnvironment().getProperty(&quot;JAVA_HOME&quot;);context.getEnvironment().getProperty(&quot;server.port&quot;); 发送事件12context.publishEvent(ApplicationEvent event);@EventListener","categories":[{"name":"ConfigurableApplicaionContext","slug":"ConfigurableApplicaionContext","permalink":"https://erdong27.github.io/categories/ConfigurableApplicaionContext/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"}]},{"title":"HashMap集合简介","slug":"HasnMap集合简介","date":"2024-07-10T06:16:10.000Z","updated":"2024-07-10T06:16:10.000Z","comments":true,"path":"2024/07/10/HasnMap集合简介/","permalink":"https://erdong27.github.io/2024/07/10/HasnMap%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1.HashMap集合简介HashMap基于哈希表的Map接口实现，是以key-Vaue存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突（两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的(“拉链法”解决冲突)JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。 补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考treeifyBin方法。当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 小结：特点： 存取无序的 键和值位置都可以是null,但是键位置只能是一个null 键位置是唯一的，底层的数据结构控制键的 jdk1.8前数据结构是：链表+数组jdk1.8之后是：链表+数组+红黑树 阈值(边界值)&gt;8并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://erdong27.github.io/tags/HashMap/"}]},{"title":"位运算符号","slug":"位运算符号","date":"2024-07-10T05:41:38.000Z","updated":"2024-07-10T07:59:41.979Z","comments":true,"path":"2024/07/10/位运算符号/","permalink":"https://erdong27.github.io/2024/07/10/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"","categories":[{"name":"位运算","slug":"位运算","permalink":"https://erdong27.github.io/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://erdong27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"从0开始搭建hexo","slug":"从0开始搭建hexo","date":"2024-07-10T01:14:28.629Z","updated":"2024-07-10T01:14:28.630Z","comments":true,"path":"2024/07/10/从0开始搭建hexo/","permalink":"https://erdong27.github.io/2024/07/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo/","excerpt":"","text":"准备环境node.js 切换淘宝源 1npm install -g cnpm --registry=https://registry.npmmirror.com 安装hexo 1cnpm install -g hexo-cli 验证hexo是否安装成功 1hexo -v 初始化hexo 12##新建一个文件夹作为hexo的根目录hexo init hexo启动 1hexo s 博客编写 1hexo n &quot;我的第一篇博客文章&quot; 生成静态文件 1hexo g 参考链接","categories":[],"tags":[]},{"title":"HashMap集合扩容方法resize的源码解析","slug":"HashMap集合扩容方法resize的源码分析","date":"2024-07-09T16:57:12.608Z","updated":"2024-07-10T13:33:42.400Z","comments":true,"path":"2024/07/10/HashMap集合扩容方法resize的源码分析/","permalink":"https://erdong27.github.io/2024/07/10/HashMap%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95resize%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 扩容方法 * 1. 计算新的容量和新的阈值 * 2. 创建新的数组 * 3. 将旧数组的元素迁移到新的数组中 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果旧数组不为空 if (oldCap &gt; 0) &#123; // 如果旧数组的容量 &gt;= MAXIMUM_CAPACITY，则将阈值设置为Integer.MAX_VALUE，并返回旧数组 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 如果旧数组的容量 &gt;= DEFAULT_INITIAL_CAPACITY，则将新数组的容量设置为旧数组的容量*2，并将阈值设置为旧阈值*2 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 如果旧阈值大于0，则将新数组的容量设置为旧阈值，并将阈值设置为旧阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 否则，将新数组的容量设置为DEFAULT_INITIAL_CAPACITY，并将阈值设置为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新阈值为0，则将新阈值设置为新数组的容量 * 负载因子，大于等于MAXIMUM_CAPACITY时，设置为Integer.MAX_VALUE if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果旧数组不为空 if (oldTab != null) &#123; // 遍历旧数组中的每个元素 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果当前元素不为空 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果当前元素的下一个元素为空 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果当前元素是一个树节点 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 否则，保持元素顺序 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://erdong27.github.io/tags/HashMap/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"},{"name":"VUE","slug":"VUE","permalink":"https://erdong27.github.io/categories/VUE/"},{"name":"数据库","slug":"数据库","permalink":"https://erdong27.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"图床","slug":"图床","permalink":"https://erdong27.github.io/categories/%E5%9B%BE%E5%BA%8A/"},{"name":"JVM","slug":"JVM","permalink":"https://erdong27.github.io/categories/JVM/"},{"name":"BeanFactory","slug":"BeanFactory","permalink":"https://erdong27.github.io/categories/BeanFactory/"},{"name":"ApplicaionContext","slug":"BeanFactory/ApplicaionContext","permalink":"https://erdong27.github.io/categories/BeanFactory/ApplicaionContext/"},{"name":"ConfigurableApplicaionContext","slug":"ConfigurableApplicaionContext","permalink":"https://erdong27.github.io/categories/ConfigurableApplicaionContext/"},{"name":"位运算","slug":"位运算","permalink":"https://erdong27.github.io/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"https://erdong27.github.io/tags/Lambda/"},{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"},{"name":"generic","slug":"generic","permalink":"https://erdong27.github.io/tags/generic/"},{"name":"VITE","slug":"VITE","permalink":"https://erdong27.github.io/tags/VITE/"},{"name":"VUE","slug":"VUE","permalink":"https://erdong27.github.io/tags/VUE/"},{"name":"Redis","slug":"Redis","permalink":"https://erdong27.github.io/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"https://erdong27.github.io/tags/NOSQL/"},{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringAop","slug":"SpringAop","permalink":"https://erdong27.github.io/tags/SpringAop/"},{"name":"CGLIB","slug":"CGLIB","permalink":"https://erdong27.github.io/tags/CGLIB/"},{"name":"代理","slug":"代理","permalink":"https://erdong27.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"图床","slug":"图床","permalink":"https://erdong27.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"SpringApplication","slug":"SpringApplication","permalink":"https://erdong27.github.io/tags/SpringApplication/"},{"name":"ApplicationListener","slug":"ApplicationListener","permalink":"https://erdong27.github.io/tags/ApplicationListener/"},{"name":"EventListener","slug":"EventListener","permalink":"https://erdong27.github.io/tags/EventListener/"},{"name":"Srping","slug":"Srping","permalink":"https://erdong27.github.io/tags/Srping/"},{"name":"EnableAutoConfiguration","slug":"EnableAutoConfiguration","permalink":"https://erdong27.github.io/tags/EnableAutoConfiguration/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://erdong27.github.io/tags/Tomcat/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://erdong27.github.io/tags/SpringMVC/"},{"name":"SpringWeb","slug":"SpringWeb","permalink":"https://erdong27.github.io/tags/SpringWeb/"},{"name":"HashMap","slug":"HashMap","permalink":"https://erdong27.github.io/tags/HashMap/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://erdong27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}