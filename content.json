{"meta":{"title":"erdong","subtitle":"毕竟几人真得鹿,不知终日梦为鱼","description":"JAVA后端开发攻城狮。","author":"erdong","url":"https://erdong27.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-07-10T07:17:45.000Z","updated":"2024-07-10T07:30:23.981Z","comments":false,"path":"about/index.html","permalink":"https://erdong27.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-07-10T01:59:50.000Z","updated":"2024-07-10T05:51:15.322Z","comments":false,"path":"tags/index.html","permalink":"https://erdong27.github.io/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2024-07-10T07:00:38.000Z","updated":"2024-07-10T07:02:13.278Z","comments":false,"path":"archives/index.html","permalink":"https://erdong27.github.io/archives/index.html","excerpt":"","text":""},{"title":"友链","date":"2024-07-10T02:51:30.000Z","updated":"2024-07-10T07:16:26.471Z","comments":false,"path":"link/index.html","permalink":"https://erdong27.github.io/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-07-10T02:01:37.000Z","updated":"2024-07-10T05:51:30.066Z","comments":false,"path":"categories/index.html","permalink":"https://erdong27.github.io/categories/index.html","excerpt":"","text":""},{"title":"留下你的想法","date":"2024-07-10T02:02:18.000Z","updated":"2024-07-10T07:25:27.063Z","comments":true,"path":"messageboard/index.html","permalink":"https://erdong27.github.io/messageboard/index.html","excerpt":"","text":"留言须知 严禁发表违反中华人民共和国相关法律的言论，包括但不限于反动、分裂、色情、诈骗等"},{"title":"","date":"2024-07-10T08:13:36.614Z","updated":"2024-07-10T08:13:16.462Z","comments":true,"path":"css/checkbox.css","permalink":"https://erdong27.github.io/css/checkbox.css","excerpt":"","text":"input[type=\"checkbox\"] { display: none !important; } input[type=\"checkbox\"] + label::before { content: '\\a0'; display: inline-block; margin-right: 0.2em; border: 1px solid; border-radius: 0.2em; width: 0.8em; height: 0.8em; vertical-align: 0.1em; text-indent: 0.1em; line-height: 0.7; cursor: not-allowed; } input[type=\"checkbox\"]:checked + label::before { content: '\\2714'; } 作者: 默烦 链接: https://mofan212.github.io/posts/Something-About-Blog/ 来源: Mofan 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"","date":"2024-07-10T08:14:49.003Z","updated":"2024-07-10T08:14:49.003Z","comments":true,"path":"js/checkbox.js","permalink":"https://erdong27.github.io/js/checkbox.js","excerpt":"","text":"/*设置 checkbox 为只读*/ window.onload = function(){ var inputs = document.getElementsByTagName(\"input\"); for(var i = 0;i < inputs.length; i++){ if(inputs[i].type == \"checkbox\"){ inputs[i].onclick = function() { this.checked = !this.checked; } } } }"}],"posts":[{"title":"SpringBoot自动配置","slug":"SpringBoot自动配置","date":"2024-07-12T14:41:21.000Z","updated":"2024-07-12T14:41:21.000Z","comments":true,"path":"2024/07/12/SpringBoot自动配置/","permalink":"https://erdong27.github.io/2024/07/12/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/","excerpt":"","text":"通过@Import&amp;@Configuration12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.github.ed.test.test5;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ConfigurationClassPostProcessor;import org.springframework.context.annotation.Import;import org.springframework.context.support.GenericApplicationContext;public class Test &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; context.close(); &#125; @Configuration @Import(&#123;Config1.class,Config2.class&#125;) static class Config&#123; &#125; @Configuration public static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; &#125; @Configuration public static class Config2&#123; @Bean public Bean2 bean1()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; &#125;&#125; 自己实现ImportSelector接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.github.ed.test.test5;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ConfigurationClassPostProcessor;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.ImportSelector;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.type.AnnotationMetadata;public class Test &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; context.close(); &#125; @Configuration @Import(&#123;MyImportSelector.class&#125;) static class Config&#123; &#125; static class MyImportSelector implements ImportSelector &#123; @Override @SuppressWarnings(&quot;all&quot;) public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;Bean1.class.getName(),Bean2.class.getName()&#125;; &#125; &#125; @Configuration public static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; &#125; @Configuration public static class Config2&#123; @Bean public Bean2 bean1()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; &#125;&#125; 通过配置文件spring.factories123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.github.ed.test.test5;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ConfigurationClassPostProcessor;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.ImportSelector;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.io.support.SpringFactoriesLoader;import org.springframework.core.type.AnnotationMetadata;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); //设置BeanDefinition不能重写 context.setAllowBeanDefinitionOverriding(false); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; System.out.println(context.getBean(Bean1.class)); context.close(); &#125; @Configuration //本项目配置类 @Import(MyImportSelector.class) public static class Config&#123; @Bean @ConditionalOnMissingBean public Bean1 bean1()&#123; return new Bean1(&quot;本项目&quot;); &#125; &#125; /** * DeferredImportSelector 可以让本项目的优先级大于第三方的 */ static class MyImportSelector implements ImportSelector &#123; @Override @SuppressWarnings(&quot;all&quot;) public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; List&lt;String&gt; loadFactoryNames = SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, null); System.out.println(&quot;==============&gt;&quot;); for (String name : loadFactoryNames) &#123; System.out.println(name); &#125; List&lt;String&gt; factoryNames = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null); return factoryNames.toArray(new String[0]); &#125; &#125; @Configuration static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(&quot;第三方&quot;); &#125; &#125; @Configuration public static class Config2&#123; @Bean public Bean2 bean2()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; @Override public String toString() &#123; return &quot;Bean1&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; @Override public String toString() &#123; return &quot;Bean2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125;&#125; 1234567891011# Auto Configure# 内部类用$com.github.ed.test.test5.Test$MyImportSelector=\\com.github.ed.test.test5.Test$Config1,\\com.github.ed.test.test5.Test$Config2org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.github.ed.test.test5.TestAopAutoConfiguration$Config1,\\com.github.ed.test.test5.TestAopAutoConfiguration$Config2 路径为resources下的META-INF&#x2F;spring.factoriespublic static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 如果本项目beanName与第三方beanName相同 默认是第三方的优先级高 实现DeferredImportSelector接口让本项目优先级高 @ConditionalOnMissingBean如果没有相同名字的bean那么使用当前这个bean 有就不用 自定义条件装配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.github.ed.test.test5;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.AnnotationConfigUtils;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.GenericApplicationContext;import org.springframework.core.env.SimpleCommandLinePropertySource;import org.springframework.core.env.StandardEnvironment;import org.springframework.core.type.AnnotatedTypeMetadata;import org.springframework.util.ClassUtils;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.Map;public class TestAopAutoConfiguration &#123; public static void main(String[] args) &#123; GenericApplicationContext context=new GenericApplicationContext(); StandardEnvironment env=new StandardEnvironment(); env.getPropertySources().addLast(new SimpleCommandLinePropertySource( &quot;--spring.aop.auto=true&quot;, &quot;--spring.datasource.url=jdbc:mysql://localhost:3306/spikes&quot;, &quot;--spring.datasource.username=root&quot;, &quot;--spring.datasource.password=&quot; )); context.setEnvironment(env); AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory()); context.registerBean(Config.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; String description = context.getBeanDefinition(name).getResourceDescription(); if(description!=null) System.out.println(name+&quot;来源：&quot;+description); &#125; context.close(); &#125; @Configuration @EnableAutoConfiguration public static class Config&#123; &#125; @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @Conditional(MyConditional1.class) @interface ConditionalOnClass&#123; boolean exists() ; String className(); &#125; @SuppressWarnings(&quot;all&quot;) static class MyConditional1 implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Map&lt;String, Object&gt; annotationAttributes = metadata.getAnnotationAttributes(ConditionalOnClass.class.getName()); String className = (String)annotationAttributes .get(&quot;className&quot;); boolean exists = (boolean) annotationAttributes.get(&quot;exists&quot;); boolean present = ClassUtils.isPresent(className, null); return exists == present; &#125; &#125; @Configuration @ConditionalOnClass(exists = false,className = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;) static class Config1&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; &#125; @Configuration @ConditionalOnClass(exists = true,className = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;) static class Config2&#123; @Bean public Bean2 bean2()&#123; return new Bean2(); &#125; &#125; static class Bean1&#123; private String name; public Bean1(String name) &#123; this.name = name; &#125; public Bean1() &#123; &#125; @Override public String toString() &#123; return &quot;Bean1&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; static class Bean2&#123; private String name; public Bean2(String name) &#123; this.name = name; &#125; public Bean2() &#123; &#125; @Override public String toString() &#123; return &quot;Bean2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Srping","slug":"Srping","permalink":"https://erdong27.github.io/tags/Srping/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"EnableAutoConfiguration","slug":"EnableAutoConfiguration","permalink":"https://erdong27.github.io/tags/EnableAutoConfiguration/"}]},{"title":"Tomcat内嵌容器","slug":"Tomcat内嵌容器","date":"2024-07-12T03:27:32.000Z","updated":"2024-07-12T03:27:32.000Z","comments":true,"path":"2024/07/12/Tomcat内嵌容器/","permalink":"https://erdong27.github.io/2024/07/12/Tomcat%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8/","excerpt":"","text":"Tomcat结构图 Tomcat内嵌容器 创建 Tomcat 对象 创建项目文件来，即docBase文件夹 创建Tomcat 项目，在Tomcat 中称为 Context 编程添加 Servlet 启动 Tomcat 创建连接器,设置监听端口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.github.ed.test.test3.test4;import org.apache.catalina.Context;import org.apache.catalina.connector.Connector;import org.apache.catalina.servlets.DefaultServlet;import org.apache.catalina.startup.Tomcat;import org.apache.coyote.http11.Http11Nio2Protocol;import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import javax.servlet.ServletContainerInitializer;import javax.servlet.ServletContext;import javax.servlet.ServletException;import java.io.File;import java.nio.file.Files;import java.util.Collections;import java.util.Set;public class TestTomcat &#123; @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) throws Exception &#123;// 1.创建 Tomcat 对象 Tomcat tomcat=new Tomcat(); tomcat.setBaseDir(&quot;tomcat&quot;);// 2.创建项目文件来，即docBase文件夹 File docBase = Files.createTempDirectory(&quot;boot.&quot;).toFile(); docBase.deleteOnExit();// 3.创建Tomcat 项目，在Tomcat 中称为 Context Context context = tomcat.addContext(&quot;&quot;, docBase.getAbsolutePath()); WebApplicationContext springContext = getApplicationContext();// 4.编程添加 Servlet context.addServletContainerInitializer(new ServletContainerInitializer() &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; cs, ServletContext ctx) throws ServletException &#123; ctx.addServlet(&quot;aaa&quot;,new DefaultServlet()).addMapping(&quot;/hello&quot;);// DispatcherServlet dispatcherServlet = springContext.getBean(DispatcherServlet.class);// ctx.addServlet(&quot;dispatcherServlet&quot;,dispatcherServlet).addMapping(&quot;/&quot;); for (ServletRegistrationBean registrationBean :springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123; registrationBean.onStartup(ctx); &#125; &#125; &#125;, Collections.emptySet());// 5.启动 Tomcat tomcat.start();// 6.创建连接器,设置监听端口 Connector connector = new Connector(new Http11Nio2Protocol()); connector.setPort(8080); tomcat.setConnector(connector); &#125; public static WebApplicationContext getApplicationContext()&#123; AnnotationConfigWebApplicationContext context=new AnnotationConfigWebApplicationContext(); context.register(Config.class); context.refresh(); return context; &#125; @Configuration static class Config &#123; @Bean public DispatcherServlet dispatcherServlet()&#123; return new DispatcherServlet(); &#125; @Bean public DispatcherServletRegistrationBean dispatcherServletRegistrationBean(DispatcherServlet dispatcherServlet)&#123; return new DispatcherServletRegistrationBean(dispatcherServlet,&quot;/&quot;) ; &#125; @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setMessageConverters(Collections.singletonList(new MappingJackson2HttpMessageConverter())); return adapter; &#125; @Controller static class Controller1 &#123; @GetMapping(&quot;/hello2&quot;) @ResponseBody public String hello()&#123; return &quot;hello2&quot;; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://erdong27.github.io/tags/Tomcat/"}]},{"title":"tomcat异常处理","slug":"tomcat异常处理","date":"2024-07-11T15:52:44.000Z","updated":"2024-07-11T15:52:44.000Z","comments":true,"path":"2024/07/11/tomcat异常处理/","permalink":"https://erdong27.github.io/2024/07/11/tomcat%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"自定义error控制器123456789101112131415161718package com.github.ed.test.test3;import org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;public class Test &#123; public static void main(String[] args) &#123; AnnotationConfigServletWebServerApplicationContext context=new AnnotationConfigServletWebServerApplicationContext(WebConfig.class); RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); requestMappingHandlerMapping.getHandlerMethods().forEach( (k,v)-&gt;&#123; System.out.println(&quot;映射路径：&quot;+k+&quot;，方法信息：&quot;+v); &#125; ); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.github.ed.test.test3;import org.springframework.boot.autoconfigure.web.ErrorProperties;import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;import org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController;import org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.ErrorPage;import org.springframework.boot.web.server.ErrorPageRegistrar;import org.springframework.boot.web.server.ErrorPageRegistrarBeanPostProcessor;import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.view.BeanNameViewResolver;import javax.servlet.RequestDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Collections;import java.util.HashMap;import java.util.Map;@Configurationpublic class WebConfig &#123; //tomcat容器创建 @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory()&#123; TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory(); return tomcatServletWebServerFactory; &#125;//DispatcherServlet创建 @Bean public DispatcherServlet dispatcherServlet()&#123; return new DispatcherServlet(); &#125;//将DispatcherServlet注册到tomcat容器中 @Bean public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet)&#123; return new DispatcherServletRegistrationBean(dispatcherServlet, &quot;/&quot;); &#125; @Bean public RequestMappingHandlerMapping requestMappingHandlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125; //默认RequestMappingHandlerAdapter没有Jackson转换器 @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setMessageConverters(Collections.singletonList(new MappingJackson2HttpMessageConverter())); return adapter; &#125; //修改Tomcat服务器默认错误页面地址 @Bean public ErrorPageRegistrar errorPageRegistrar()&#123; return registry -&gt; registry.addErrorPages(new ErrorPage(&quot;/error&quot;)); &#125; //错误注册中心后置处理器 @Bean public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor()&#123; return new ErrorPageRegistrarBeanPostProcessor(); &#125; @Controller static class Controller1&#123; @RequestMapping(&quot;/test&quot;) public ModelAndView test()&#123; int i=1/0; return null; &#125; @RequestMapping(&quot;/error&quot;) @ResponseBody public Map&lt;String,Object&gt; error(HttpServletRequest request)&#123; Throwable e = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;error&quot;, e.getMessage()); return map; &#125; &#125;&#125; BasicErrorController方式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.github.ed.test.test3;import org.springframework.boot.autoconfigure.web.ErrorProperties;import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;import org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController;import org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.ErrorPage;import org.springframework.boot.web.server.ErrorPageRegistrar;import org.springframework.boot.web.server.ErrorPageRegistrarBeanPostProcessor;import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.view.BeanNameViewResolver;import javax.servlet.RequestDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Collections;import java.util.HashMap;import java.util.Map;@Configurationpublic class WebConfig &#123; @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory()&#123; TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory(); return tomcatServletWebServerFactory; &#125; @Bean public DispatcherServlet dispatcherServlet()&#123; return new DispatcherServlet(); &#125; @Bean public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet)&#123; return new DispatcherServletRegistrationBean(dispatcherServlet, &quot;/&quot;); &#125; @Bean public RequestMappingHandlerMapping requestMappingHandlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125;//默认RequestMappingHandlerAdapter没有Jackson转换器 @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setMessageConverters(Collections.singletonList(new MappingJackson2HttpMessageConverter())); return adapter; &#125; //修改Tomcat服务器默认错误页面地址 @Bean public ErrorPageRegistrar errorPageRegistrar()&#123; return registry -&gt; registry.addErrorPages(new ErrorPage(&quot;/error&quot;)); &#125; //错误注册中心后置处理器 @Bean public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor()&#123; return new ErrorPageRegistrarBeanPostProcessor(); &#125; @Bean public BasicErrorController basicErrorController()&#123; ErrorProperties errorProperties = new ErrorProperties(); errorProperties.setIncludeException(true); return new BasicErrorController(new DefaultErrorAttributes(), errorProperties); &#125; @Bean public View error()&#123; return new View() &#123; @Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(&quot;&lt;h3&gt;服务器内部错误&lt;/h3&gt;&quot;); &#125; &#125;; &#125; @Bean public ViewResolver viewResolver()&#123; return new BeanNameViewResolver(); &#125; @Controller static class Controller1&#123; @RequestMapping(&quot;/test&quot;) public ModelAndView test()&#123; int i=1/0; return null; &#125; &#125;&#125; 在浏览器访问时 响应头为content-type:text/html不能正确处理 要自定义视图View 响应头中content-type:application/json格式的可以正常访问","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://erdong27.github.io/tags/SpringMVC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://erdong27.github.io/tags/Tomcat/"}]},{"title":"对象绑定与类型转换","slug":"对象绑定与类型转换","date":"2024-07-10T12:34:57.000Z","updated":"2024-07-10T12:34:57.000Z","comments":true,"path":"2024/07/10/对象绑定与类型转换/","permalink":"https://erdong27.github.io/2024/07/10/%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"底层第一套转换接口 底层第二套转换接口 高层接口与实现 演示SimpleTypeConverter1234567891011121314151617package com.github.ed.test.test1;import org.springframework.beans.SimpleTypeConverter;import java.util.Date;public class TestSimpleTypeConverter &#123; public static void main(String[] args) &#123; SimpleTypeConverter simpleTypeConverter=new org.springframework.beans.SimpleTypeConverter(); Integer number = simpleTypeConverter.convertIfNecessary(&quot;13&quot;, int.class); Date date = simpleTypeConverter.convertIfNecessary(&quot;1997/03/21&quot;, Date.class); System.out.println(number); System.out.println(date); &#125;&#125; DirectFieldAccessor1234567891011121314151617181920212223242526272829303132333435363738package com.github.ed.test.test1;import org.springframework.beans.DirectFieldAccessor;import java.util.Date;/** * 走成员变量赋值 */public class TestFieldWrapper &#123; public static void main(String[] args) &#123; TestBeanWrapper.MyBean target = new TestBeanWrapper.MyBean(); DirectFieldAccessor directFieldAccessor=new DirectFieldAccessor(target); directFieldAccessor.setPropertyValue(&quot;a&quot;,&quot;10&quot;); directFieldAccessor.setPropertyValue(&quot;b&quot;,&quot;hello&quot;); directFieldAccessor.setPropertyValue(&quot;c&quot;,&quot;1997/03/21&quot;); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; BeanWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.github.ed.test.test1;import org.springframework.beans.BeanWrapper;import org.springframework.beans.BeanWrapperImpl;import java.util.Date;/** * 走反射set方法赋值 */public class TestBeanWrapper &#123; public static void main(String[] args) &#123; MyBean target = new MyBean(); BeanWrapper beanWrapper=new BeanWrapperImpl(target); beanWrapper.setPropertyValue(&quot;a&quot;,&quot;10&quot;); beanWrapper.setPropertyValue(&quot;b&quot;,&quot;hello&quot;); beanWrapper.setPropertyValue(&quot;c&quot;,&quot;1997/03/21&quot;); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Date getC() &#123; return c; &#125; public void setC(Date c) &#123; this.c = c; &#125; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; DataBinder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.github.ed.test.test1;import org.springframework.beans.MutablePropertyValues;import org.springframework.validation.DataBinder;import java.util.Date;/** * 有两种方式 * 1.走反射set方法 * 2. dataBinder.initDirectFieldAccess(); */public class TestDateBinder &#123; public static void main(String[] args) &#123; MyBean target = new MyBean(); DataBinder dataBinder=new DataBinder(target); dataBinder.initDirectFieldAccess(); MutablePropertyValues pvs=new MutablePropertyValues(); pvs.add(&quot;a&quot;,&quot;10&quot;); pvs.add(&quot;b&quot;,&quot;hello&quot;); pvs.add(&quot;c&quot;,&quot;1997/03/21&quot;); dataBinder.bind(pvs); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Date getC() &#123; return c; &#125; public void setC(Date c) &#123; this.c = c; &#125; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; Web环境下数据绑定ServletRequestDataBinder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.github.ed.test.test1;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.web.bind.ServletRequestDataBinder;import org.springframework.web.bind.ServletRequestParameterPropertyValues;import java.util.Date;public class TestServletRequestDataBinder &#123; public static void main(String[] args) &#123; //web环境下数据绑定 MyBean target = new MyBean(); ServletRequestDataBinder dataBinder=new ServletRequestDataBinder(target); MockHttpServletRequest request=new MockHttpServletRequest(); request.setParameter(&quot;a&quot;,&quot;10&quot;); request.setParameter(&quot;b&quot;,&quot;hello&quot;); request.setParameter(&quot;c&quot;,&quot;1997/03/21&quot;); dataBinder.bind(new ServletRequestParameterPropertyValues(request)); System.out.println(target); &#125; static class MyBean&#123; private int a; private String b; private Date c; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Date getC() &#123; return c; &#125; public void setC(Date c) &#123; this.c = c; &#125; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125; &#125;&#125; 参考链接","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://erdong27.github.io/tags/SpringMVC/"},{"name":"SpringWeb","slug":"SpringWeb","permalink":"https://erdong27.github.io/tags/SpringWeb/"}]},{"title":"获取方法参数名","slug":"获取参数名","date":"2024-07-10T12:19:39.000Z","updated":"2024-07-10T12:19:39.000Z","comments":true,"path":"2024/07/10/获取参数名/","permalink":"https://erdong27.github.io/2024/07/10/%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%90%8D/","excerpt":"","text":"12#编译成class文件javac xxx.java 12# class里面有加本地变量表 asm使用 被编译的是接口方法无效javac -g xxx.java 12# class里面有加方法参数 jdk反射使用使用javac -parameters xxx.java 12# 反编译查看javap -c -v xxx.java 测试javac -parameters1234567891011121314151617181920package com.github.ed.test.test2;import java.lang.reflect.Method;import java.lang.reflect.Parameter;public class Bean1 &#123; public void foo(String name,String value)&#123; &#125; public static void main(String[] args) throws Exception &#123; Method method = Bean1.class.getMethod(&quot;foo&quot;, String.class,String.class); for (Parameter parameter : method.getParameters()) &#123; System.out.println(parameter.getName()); &#125; &#125;&#125; javac -g123456789101112131415package com.github.ed.test.test2;import org.springframework.core.LocalVariableTableParameterNameDiscoverer;public class A22 &#123; public static void main(String[] args) &#123; LocalVariableTableParameterNameDiscoverer localVariableTableParameterNameDiscoverer=new LocalVariableTableParameterNameDiscoverer(); String[] names = localVariableTableParameterNameDiscoverer.getParameterNames(Bean1.class.getMethod(&quot;foo&quot;, String.class, String.class)); for (String name : names) &#123; System.out.println(name); &#125; &#125;&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"https://erdong27.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"}]},{"title":"BeanFactory容器的实现","slug":"BeanFactory容器实现","date":"2024-07-10T08:41:34.000Z","updated":"2024-07-10T08:41:34.000Z","comments":true,"path":"2024/07/10/BeanFactory容器实现/","permalink":"https://erdong27.github.io/2024/07/10/BeanFactory%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 @Configuration static class Config&#123; @Bean public Bean1 bean1()&#123; return new Bean1(); &#125; @Bean public Bean2 bean2()&#123; return new Bean2(); &#125; @Bean public Bean3 bean3()&#123; return new Bean3(); &#125; @Bean public Bean4 bean4()&#123; return new Bean4(); &#125; interface Inter &#123; &#125; static class Bean1&#123; public Bean1() &#123; System.out.println(&quot;Bean1构造器&quot;); &#125; @Autowired private Bean2 bean2; @Autowired @Resource(name = &quot;bean4&quot;) private Inter bean3; public Bean2 getBean2() &#123; return bean2; &#125; public Inter getInter()&#123; return bean3; &#125; &#125; static class Bean2&#123; public Bean2() &#123; System.out.println(&quot;Bean2构造器&quot;); &#125; &#125; static class Bean3 implements Inter&#123; public Bean3() &#123; System.out.println(&quot;Bean3构造器&quot;); &#125; &#125; static class Bean4 implements Inter&#123; public Bean4() &#123; System.out.println(&quot;Bean4构造器&quot;); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; &#125; 添加beanFactory后置处理器1234567891011121314151617public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); //添加常用的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //BeanFactory 后置处理器主要功能 补充一些bean定义 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach( beanFactoryPostProcessor-&gt;&#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); &#125;); for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; System.out.println(beanFactory.getBean(Config.Bean1.class).getBean2());&#125; 添加bean后置处理器1234567891011121314151617181920212223public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); //添加常用的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //BeanFactory 后置处理器主要功能 补充一些bean定义 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach( beanFactoryPostProcessor-&gt;&#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); &#125;); //Bean后处理器 针对bean的生命周期的各个阶段提供扩展 例如@Autowired @Resource for (BeanPostProcessor beanPostProcessor : beanFactory.getBeansOfType(BeanPostProcessor.class).values()) &#123; beanFactory.addBeanPostProcessor(beanPostProcessor); &#125; for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; beanFactory.preInstantiateSingletons();//准备好所有单例 System.out.println(&quot;==============&gt;&quot;); System.out.println(beanFactory.getBean(Config.Bean1.class).getBean2());&#125; 总结beanFactory不会做的事 不会主动调用BeanFactory后置处理器 不会主动添加bean后置处理器 不会主动初始化单例 不会解析beanFactory 不会解析${} #{} bean后置处理器会有排序的逻辑先加载的后置处理器优先级高1234567891011121314151617181920212223242526public static void main(String[] args) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //bean的定义(class,scope,初始化，销毁) AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition(); beanFactory.registerBeanDefinition(&quot;config&quot;,beanDefinition); //添加常用的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //BeanFactory 后置处理器主要功能 补充一些bean定义 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach( beanFactoryPostProcessor-&gt;&#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); &#125;); //Bean后处理器 针对bean的生命周期的各个阶段提供扩展 例如@Autowired @Resource beanFactory.getBeansOfType(BeanPostProcessor.class) .values().stream().sorted(beanFactory.getDependencyComparator()).forEach(beanPostProcessor -&gt; &#123; System.out.println(&quot;===&gt;&quot;+beanPostProcessor); beanFactory.addBeanPostProcessor(beanPostProcessor); &#125;); for (String name : beanFactory.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; beanFactory.preInstantiateSingletons();//准备好所有单例 System.out.println(&quot;==============&gt;&quot;); System.out.println(beanFactory.getBean(Config.Bean1.class).getInter());&#125;","categories":[{"name":"BeanFactory","slug":"BeanFactory","permalink":"https://erdong27.github.io/categories/BeanFactory/"},{"name":"ApplicaionContext","slug":"BeanFactory/ApplicaionContext","permalink":"https://erdong27.github.io/categories/BeanFactory/ApplicaionContext/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"}]},{"title":"ConfigurableApplicaionContext","slug":"容器接口ApplicationContext","date":"2024-07-10T08:34:50.000Z","updated":"2024-07-10T08:34:50.000Z","comments":true,"path":"2024/07/10/容器接口ApplicationContext/","permalink":"https://erdong27.github.io/2024/07/10/%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3ApplicationContext/","excerpt":"","text":"ConfigurableApplicaionContext类图 国际化1context.getMessage(&quot;hi&quot;,null, Locale.CANADA); 根据通配符获取资源1context.getResources(&quot;classpath*:top/javahai/subtlechat/test/**/*.class&quot;); “classpath*”中的 星号表示jar包中的也会扫描到 获取配置信息环境变量12context.getEnvironment().getProperty(&quot;JAVA_HOME&quot;);context.getEnvironment().getProperty(&quot;server.port&quot;); 发送事件12context.publishEvent(ApplicationEvent event);@EventListener","categories":[{"name":"ConfigurableApplicaionContext","slug":"ConfigurableApplicaionContext","permalink":"https://erdong27.github.io/categories/ConfigurableApplicaionContext/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"}]},{"title":"HashMap集合简介","slug":"HasnMap集合简介","date":"2024-07-10T06:16:10.000Z","updated":"2024-07-10T06:16:10.000Z","comments":true,"path":"2024/07/10/HasnMap集合简介/","permalink":"https://erdong27.github.io/2024/07/10/HasnMap%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1.HashMap集合简介HashMap基于哈希表的Map接口实现，是以key-Vaue存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突（两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的(“拉链法”解决冲突)JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。 补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考treeifyBin方法。当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 小结：特点： 存取无序的 键和值位置都可以是null,但是键位置只能是一个null 键位置是唯一的，底层的数据结构控制键的 jdk1.8前数据结构是：链表+数组jdk1.8之后是：链表+数组+红黑树 阈值(边界值)&gt;8并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。","categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://erdong27.github.io/tags/HashMap/"}]},{"title":"位运算符号","slug":"位运算符号","date":"2024-07-10T05:41:38.000Z","updated":"2024-07-10T07:59:41.979Z","comments":true,"path":"2024/07/10/位运算符号/","permalink":"https://erdong27.github.io/2024/07/10/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"","categories":[{"name":"位运算","slug":"位运算","permalink":"https://erdong27.github.io/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://erdong27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"从0开始搭建hexo","slug":"从0开始搭建hexo","date":"2024-07-10T01:14:28.629Z","updated":"2024-07-10T01:14:28.630Z","comments":true,"path":"2024/07/10/从0开始搭建hexo/","permalink":"https://erdong27.github.io/2024/07/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo/","excerpt":"","text":"准备环境node.js 切换淘宝源 1npm install -g cnpm --registry=https://registry.npmmirror.com 安装hexo 1cnpm install -g hexo-cli 验证hexo是否安装成功 1hexo -v 初始化hexo 12##新建一个文件夹作为hexo的根目录hexo init hexo启动 1hexo s 博客编写 1hexo n &quot;我的第一篇博客文章&quot; 生成静态文件 1hexo g 参考链接","categories":[],"tags":[]},{"title":"HashMap集合扩容方法resize的源码解析","slug":"HashMap集合扩容方法resize的源码分析","date":"2024-07-09T16:57:12.608Z","updated":"2024-07-10T13:33:42.400Z","comments":true,"path":"2024/07/10/HashMap集合扩容方法resize的源码分析/","permalink":"https://erdong27.github.io/2024/07/10/HashMap%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95resize%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 扩容方法 * 1. 计算新的容量和新的阈值 * 2. 创建新的数组 * 3. 将旧数组的元素迁移到新的数组中 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果旧数组不为空 if (oldCap &gt; 0) &#123; // 如果旧数组的容量 &gt;= MAXIMUM_CAPACITY，则将阈值设置为Integer.MAX_VALUE，并返回旧数组 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 如果旧数组的容量 &gt;= DEFAULT_INITIAL_CAPACITY，则将新数组的容量设置为旧数组的容量*2，并将阈值设置为旧阈值*2 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 如果旧阈值大于0，则将新数组的容量设置为旧阈值，并将阈值设置为旧阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 否则，将新数组的容量设置为DEFAULT_INITIAL_CAPACITY，并将阈值设置为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新阈值为0，则将新阈值设置为新数组的容量 * 负载因子，大于等于MAXIMUM_CAPACITY时，设置为Integer.MAX_VALUE if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果旧数组不为空 if (oldTab != null) &#123; // 遍历旧数组中的每个元素 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果当前元素不为空 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果当前元素的下一个元素为空 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果当前元素是一个树节点 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 否则，保持元素顺序 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","categories":[],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://erdong27.github.io/tags/HashMap/"},{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/categories/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://erdong27.github.io/categories/JVM/"},{"name":"BeanFactory","slug":"BeanFactory","permalink":"https://erdong27.github.io/categories/BeanFactory/"},{"name":"ApplicaionContext","slug":"BeanFactory/ApplicaionContext","permalink":"https://erdong27.github.io/categories/BeanFactory/ApplicaionContext/"},{"name":"ConfigurableApplicaionContext","slug":"ConfigurableApplicaionContext","permalink":"https://erdong27.github.io/categories/ConfigurableApplicaionContext/"},{"name":"位运算","slug":"位运算","permalink":"https://erdong27.github.io/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"Srping","slug":"Srping","permalink":"https://erdong27.github.io/tags/Srping/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://erdong27.github.io/tags/SpringBoot/"},{"name":"EnableAutoConfiguration","slug":"EnableAutoConfiguration","permalink":"https://erdong27.github.io/tags/EnableAutoConfiguration/"},{"name":"Spring","slug":"Spring","permalink":"https://erdong27.github.io/tags/Spring/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://erdong27.github.io/tags/Tomcat/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://erdong27.github.io/tags/SpringMVC/"},{"name":"SpringWeb","slug":"SpringWeb","permalink":"https://erdong27.github.io/tags/SpringWeb/"},{"name":"Java","slug":"Java","permalink":"https://erdong27.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://erdong27.github.io/tags/HashMap/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://erdong27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}